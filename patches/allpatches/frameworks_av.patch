diff --git a/camera/Android.mk b/camera/Android.mk
index 431f73300..3d263641c 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -39,6 +39,12 @@ LOCAL_SRC_FILES:= \
 	CameraUtils.cpp \
 	VendorTagDescriptor.cpp
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+	LOCAL_SRC_FILES+= \
+	MtkCamera.cpp \
+	MtkCameraParameters.cpp
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
 	libutils \
@@ -59,6 +65,10 @@ else
 LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_parameters
 endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_CFLAGS += -DMTK_MT6589
+endif
+
 LOCAL_MODULE:= libcamera_client
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/camera/tests/Android.mk b/camera/tests/Android.mk
index 61385e526..9f86aa809 100644
--- a/camera/tests/Android.mk
+++ b/camera/tests/Android.mk
@@ -48,6 +48,9 @@ LOCAL_C_INCLUDES += \
 	frameworks/native/include \
 
 LOCAL_CFLAGS += -Wall -Wextra
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_CFLAGS += -DMTK_MT6589
+endif
 
 LOCAL_MODULE:= camera_client_test
 LOCAL_MODULE_TAGS := tests
diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index 698bf2eec..f0912cf38 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -44,6 +44,36 @@ public:
      * only privileged processes can have access to them
      */
 
+#ifdef MTK_HARDWARE
+    static int xWayPlay_Start(int sample_rate);
+    static int xWayPlay_Stop(void);
+    static int xWayPlay_Write(void *buffer, int size_bytes);
+    static int xWayPlay_GetFreeBufferCount(void);
+    static int xWayRec_Start(int sample_rate);
+    static int xWayRec_Stop(void);
+    static int xWayRec_Read(void *buffer, int size_bytes);
+
+    //add by wendy
+    static int ReadRefFromRing(void*buf, uint32_t datasz,void* DLtime);
+    static int GetVoiceUnlockULTime(void* DLtime);
+    static int SetVoiceUnlockSRC(uint outSR, uint outChannel);
+    static bool startVoiceUnlockDL();
+    static bool stopVoiceUnlockDL();
+    static void freeVoiceUnlockDLInstance();
+    static bool getVoiceUnlockDLInstance();
+    static int GetVoiceUnlockDLLatency();
+
+    //add . for AM mode set/get  parameters
+    static status_t GetEMParameter(void *ptr,size_t len);
+    static status_t SetEMParameter(void *ptr,size_t len);
+    static status_t SetAudioCommand(int par1,int par2);
+    static status_t GetAudioCommand(int par1, int *par2);
+    static status_t SetAudioData(int par1,size_t len, void *ptr);
+    static status_t GetAudioData(int par1,size_t len,void *ptr);
+    static status_t SetACFPreviewParameter(void *ptr,size_t len);
+    static status_t SetHCFPreviewParameter(void *ptr,size_t len);
+#endif
+
     // mute/unmute microphone
     static status_t muteMicrophone(bool state);
     static status_t isMicrophoneMuted(bool *state);
diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 2add89637..81cfdb09f 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -568,7 +568,8 @@ public:
      * false for the method to return immediately without waiting to try multiple times to write
      * the full content of the buffer.
      */
-            ssize_t     write(const void* buffer, size_t size, bool blocking = true);
+            ssize_t     write(const void* buffer, size_t size);
+            ssize_t     write(const void* buffer, size_t size, bool blocking);
 
     /*
      * Dumps the state of an audio track.
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 54be5f38d..dc82377fc 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -258,6 +258,10 @@ public:
 
     /* Get the HW synchronization source used for an audio session */
     virtual audio_hw_sync_t getAudioHwSyncForSession(audio_session_t sessionId) = 0;
+#ifdef MTK_HARDWARE
+    virtual status_t SetAudioData(int par1,size_t len,void *ptr)=0;
+    virtual status_t GetAudioData(int par1,size_t len,void *ptr)=0;
+#endif
 };
 
 
diff --git a/include/media/IAudioPolicyService.h b/include/media/IAudioPolicyService.h
index c98c475b2..8e66f515e 100644
--- a/include/media/IAudioPolicyService.h
+++ b/include/media/IAudioPolicyService.h
@@ -153,6 +153,11 @@ public:
     virtual audio_mode_t getPhoneState() = 0;
 
     virtual status_t registerPolicyMixes(Vector<AudioMix> mixes, bool registration) = 0;
+
+#ifdef MTK_HARDWARE
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4) = 0;
+#endif
+
 };
 
 
diff --git a/include/media/IOMX.h b/include/media/IOMX.h
index 6e4a4acf5..4653f33c9 100644
--- a/include/media/IOMX.h
+++ b/include/media/IOMX.h
@@ -27,6 +27,9 @@
 #include <OMX_Core.h>
 #include <OMX_Video.h>
 
+#ifdef MTK_HARDWARE
+#include <binder/IMemory.h>
+#endif
 namespace android {
 
 class IMemory;
@@ -156,6 +159,25 @@ public:
             InternalOptionType type,
             const void *data,
             size_t size) = 0;
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) = 0;
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) = 0;
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) = 0;
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) = 0;
+
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) = 0;
+#endif
 };
 
 struct omx_message {
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index b95f949ec..3a9611136 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -54,6 +54,9 @@ enum player_type {
     // argument to the 'test:' url in the setDataSource call.
     TEST_PLAYER = 5,
     DASH_PLAYER = 6,
+#ifdef MTK_HARDWARE
+    FM_AUDIO_PLAYER = 7,
+#endif
 };
 
 
diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index 0509a7c04..f981053e4 100755
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -44,7 +44,22 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_HEVC4kUHD = 17,
     CAMCORDER_QUALITY_HEVC4kDCI = 18,
     CAMCORDER_QUALITY_HVGA = 19,
+#ifdef MTK_HARDWARE
+    CAMCORDER_QUALITY_MTK_LOW              = 20,
+    CAMCORDER_QUALITY_MTK_MEDIUM           = 21,
+    CAMCORDER_QUALITY_MTK_HIGH             = 22,
+    CAMCORDER_QUALITY_MTK_FINE             = 23,
+    CAMCORDER_QUALITY_MTK_NIGHT_LOW        = 24,
+    CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM     = 25,
+    CAMCORDER_QUALITY_MTK_NIGHT_HIGH       = 26,
+    CAMCORDER_QUALITY_MTK_NIGHT_FINE       = 27,
+    CAMCORDER_QUALITY_MTK_LIVE_EFFECT      = 28,
+    CAMCORDER_QUALITY_MTK_H264_HIGH        = 29,
+    CAMCORDER_QUALITY_MTK_MPEG4_1080P      = 30,
+    CAMCORDER_QUALITY_LIST_END = 30,
+#else
     CAMCORDER_QUALITY_LIST_END = 19,
+#endif
 
     CAMCORDER_QUALITY_TIME_LAPSE_LIST_START = 1000,
     CAMCORDER_QUALITY_TIME_LAPSE_LOW  = 1000,
@@ -61,7 +76,22 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_TIME_LAPSE_WQVGA = 1012,
     CAMCORDER_QUALITY_TIME_LAPSE_FWVGA = 1013,
     CAMCORDER_QUALITY_TIME_LAPSE_4kDCI = 1014,
+#ifdef MTK_HARDWARE
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW              = 1015,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM           = 1016,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH             = 1017,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE             = 1018,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW        = 1019,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM     = 1021,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH       = 1022,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE       = 1023,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT      = 1024,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH        = 1025,
+    CAMCORDER_QUALITY_MTK_TIME_LAPSE_MPEG4_1080P      = 1026,
+    CAMCORDER_QUALITY_TIME_LAPSE_LIST_END             = 1026,
+#else
     CAMCORDER_QUALITY_TIME_LAPSE_LIST_END = 1014,
+#endif
 
     CAMCORDER_QUALITY_HIGH_SPEED_LIST_START = 2000,
     CAMCORDER_QUALITY_HIGH_SPEED_LOW  = 2000,
@@ -72,6 +102,19 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_HIGH_SPEED_2160P = 2005,
     CAMCORDER_QUALITY_HIGH_SPEED_LIST_END = 2005,
 };
+
+#ifdef MTK_HARDWARE
+enum camcorder_mode {
+    CAMCORDER_DAY_MODE   = 1,
+    CAMCORDER_NIGHT_MODE = 2,
+};
+
+enum camera_id {
+    BACK_CAMERA  = 0,
+    FRONT_CAMERA = 1,
+};
+#endif
+
 /**
  * Set CIF as default maximum import and export resolution of video editor.
  * The maximum import and export resolutions are platform specific,
@@ -83,10 +126,10 @@ enum camcorder_quality {
  * than video editor engine produces.
  */
 enum videoeditor_capability {
-    VIDEOEDITOR_DEFAULT_MAX_INPUT_FRAME_WIDTH = 352,
-    VIDEOEDITOR_DEFUALT_MAX_INPUT_FRAME_HEIGHT = 288,
-    VIDEOEDITOR_DEFAULT_MAX_OUTPUT_FRAME_WIDTH = 352,
-    VIDEOEDITOR_DEFUALT_MAX_OUTPUT_FRAME_HEIGHT = 288,
+    VIDEOEDITOR_DEFAULT_MAX_INPUT_FRAME_WIDTH = 1920,
+    VIDEOEDITOR_DEFUALT_MAX_INPUT_FRAME_HEIGHT = 1088,
+    VIDEOEDITOR_DEFAULT_MAX_OUTPUT_FRAME_WIDTH = 1280,
+    VIDEOEDITOR_DEFUALT_MAX_OUTPUT_FRAME_HEIGHT = 720,
     VIDEOEDITOR_DEFAULT_MAX_PREFETCH_YUV_FRAMES = 6
 };
 
@@ -224,6 +267,10 @@ public:
      */
     Vector<int> getImageEncodingQualityLevels(int cameraId) const;
 
+#ifdef MTK_HARDWARE
+    String8 getCamcorderProfilesCaps(int id = 0);
+    size_t getCamcorderProfilesNum(int id = 0);
+#endif
     /**
      * Returns the start time offset (in ms) for the given camera Id.
      * If the given camera Id does not exist, -1 will be returned.
@@ -476,6 +523,26 @@ private:
             MediaProfiles::CamcorderProfile **highTimeLapseProfile,
             MediaProfiles::CamcorderProfile **highSpecificTimeLapseProfile);
 
+#ifdef MTK_HARDWARE
+    static CamcorderProfile *createMTKCamcorderProfile
+        (camcorder_quality quality, camcorder_mode CamMode, camera_id CamId);
+    static CamcorderProfile *createDefaultCamcorderFrontQcifProfile(camcorder_quality quality);
+    static CamcorderProfile *createDefaultCamcorderFrontCifProfile(camcorder_quality quality);
+    static CamcorderProfile *createDefaultCamcorderFrontTimeLapseQcifProfile(camcorder_quality quality);
+    static CamcorderProfile *createDefaultCamcorderFrontTimeLapse480pProfile(camcorder_quality quality);
+    static void createDefaultCamcorderFrontLowProfiles(
+            MediaProfiles::CamcorderProfile **lowProfile,
+            MediaProfiles::CamcorderProfile **lowSpecificProfile);
+    static void createDefaultCamcorderFrontHighProfiles(
+            MediaProfiles::CamcorderProfile **highProfile,
+            MediaProfiles::CamcorderProfile **highSpecificProfile);
+    static void createDefaultCamcorderFrontTimeLapseLowProfiles(
+            MediaProfiles::CamcorderProfile **lowTimeLapseProfile,
+            MediaProfiles::CamcorderProfile **lowSpecificTimeLapseProfile);
+    static void createDefaultCamcorderFrontTimeLapseHighProfiles(
+            MediaProfiles::CamcorderProfile **highTimeLapseProfile,
+            MediaProfiles::CamcorderProfile **highSpecificTimeLapseProfile);
+#endif
     static void createDefaultCamcorderProfiles(MediaProfiles *profiles);
     static void createDefaultVideoEncoders(MediaProfiles *profiles);
     static void createDefaultAudioEncoders(MediaProfiles *profiles);
@@ -489,6 +556,9 @@ private:
 
     static VideoEncoderCap* createDefaultH263VideoEncoderCap();
     static VideoEncoderCap* createDefaultM4vVideoEncoderCap();
+#ifdef MTK_HARDWARE
+    static VideoEncoderCap* createDefaultH264VideoEncoderCap();
+#endif
     static AudioEncoderCap* createDefaultAmrNBEncoderCap();
     static AudioEncoderCap* createDefaultAacEncoderCap();
     static AudioEncoderCap* createDefaultLpcmEncoderCap();
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 3ffac34a5..106d4682c 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -31,6 +31,10 @@
 
 #define TRACK_BUFFER_TIMING     0
 
+#ifdef MTK_HARDWARE
+#define VIDEO_M4U_MAX_BUFFER 100
+#endif
+
 #define CODEC_PLAYER_STATS(func, ...) \
     do { \
         if(mCodec != NULL && mCodec->mMediaExtendedStats != NULL) { \
@@ -64,6 +68,15 @@ struct ACodec : public AHierarchicalStateMachine, public CodecBase {
     virtual void signalEndOfInputStream();
     virtual void signalRequestIDRFrame();
 
+#ifdef MTK_HARDWARE
+    void signalVEncIInterval(int seconds);
+    status_t setVEncIInterval(int seconds);     //should be private
+    void signalVEncBitRate(int bitrate);
+    status_t setVEncBitRate(int bitrate);       //should be private
+    void signalVEncFrameRate(int framerate);
+    status_t setVEncFrameRate(int framerate);   //should be private
+#endif
+
     // AHierarchicalStateMachine implements the message handling
     virtual void onMessageReceived(const sp<AMessage> &msg) {
         handleMessage(msg);
@@ -129,6 +142,11 @@ private:
         kWhatRequestIDRFrame         = 'ridr',
         kWhatSetParameters           = 'setP',
         kWhatSubmitOutputMetaDataBufferIfEOS = 'subm',
+#ifdef MTK_HARDWARE
+        kWhatMtkVEncIFrameInterval   = 'MVeI',
+        kWhatMtkVEncBitRate          = 'MVeB',
+        kWhatMtkVEncFrameRate        = 'MVeF',
+#endif
         kWhatOMXDied                 = 'OMXd',
         kWhatReleaseCodecInstance    = 'relC',
     };
@@ -151,6 +169,9 @@ private:
             OWNED_BY_UPSTREAM,
             OWNED_BY_DOWNSTREAM,
             OWNED_BY_NATIVE_WINDOW,
+#ifdef MTK_HARDWARE
+            OWNED_BY_UNEXPECTED
+#endif
         };
 
         IOMX::buffer_id mBufferID;
@@ -203,6 +224,26 @@ private:
     List<sp<AMessage> > mDeferredQueue;
 
     bool mSentFormat;
+#ifdef MTK_HARDWARE
+    bool mSupportsPartialFrames;
+    bool mIsVideoDecoder;
+    bool mIsVideoEncoder;
+    sp<ABuffer> mLeftOverBuffer;
+    int32_t mMaxQueueBufferNum;
+    FILE* mDumpFile;
+    bool mIsDumpFile;
+    int32_t mVideoAspectRatioWidth;
+    int32_t mVideoAspectRatioHeight;
+    bool mIsDemandNormalYUV;
+    size_t mAlignedSize;
+    void*  mM4UBufferHandle;
+    bool mIsDumpProflingFile;
+    unsigned long mM4UBufferCount;
+    unsigned long mM4UBufferSize[VIDEO_M4U_MAX_BUFFER];
+    unsigned long mM4UBufferVa[VIDEO_M4U_MAX_BUFFER]; 
+    unsigned long mM4UBufferPa[VIDEO_M4U_MAX_BUFFER];
+    unsigned long mM4UBufferHdr[VIDEO_M4U_MAX_BUFFER];
+#endif
     bool mIsEncoder;
     bool mUseMetadataOnEncoderOutput;
     bool mFatalError;
@@ -229,6 +270,14 @@ private:
     int64_t mRepeatFrameDelayUs;
     int64_t mMaxPtsGapUs;
 
+#ifdef MTK_HARDWARE
+    int32_t mIsVideoEncoderInputSurface;
+#if APPLY_CHECKING_FLUSH_COMPLETED
+    uint32_t mTotalTimeDuringCheckFlush;
+    int32_t mPortsFlushComplete;
+#endif //APPLY_CHECKING_FLUSH_COMPLETED
+#endif
+
     int64_t mTimePerFrameUs;
     int64_t mTimePerCaptureUs;
 
diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index 85b841a3e..0f7fd64b9 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -91,7 +91,11 @@ public:
                                           Size videoSize,
                                           int32_t frameRate,
                                           const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+										 bool storeMetaDataInVideoBuffers = false, bool supportMCIbuffer = false);
+#else
                                           bool storeMetaDataInVideoBuffers = false);
+#endif
 
     virtual ~CameraSource();
 
@@ -130,6 +134,11 @@ public:
 
     virtual void signalBufferReturned(MediaBuffer* buffer);
 
+#ifdef MTK_HARDWARE
+	status_t setFrameRate(int32_t fps);
+//	status_t pause();
+	status_t resume();
+#endif
 protected:
     class ProxyListener: public BnCameraRecordingProxyListener {
     public:
@@ -184,8 +193,11 @@ protected:
                  int32_t cameraId, const String16& clientName, uid_t clientUid,
                  Size videoSize, int32_t frameRate,
                  const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+				bool storeMetaDataInVideoBuffers,bool supportMCIbuffer = false);	
+#else
                  bool storeMetaDataInVideoBuffers);
-
+#endif
     virtual status_t startCameraRecording();
     virtual void releaseRecordingFrame(const sp<IMemory>& frame);
 
@@ -255,6 +267,24 @@ private:
     void stopCameraRecording();
     status_t reset();
 
+#ifdef MTK_HARDWARE
+	void releaseCamera_l(bool locked = false);
+    float mDropRate;
+	int32_t mNumRemainFrameReceived;
+	int32_t mLastNumFramesReceived;
+	int32_t mCamVideoBufferMode;
+	//void* mVecCamBufInfo;
+	uint32_t* mCamMemVaArray;
+	int32_t* mCamMemIonFdArray;
+
+	//for MCI buffer to save bandwith during recording
+	bool mSupportMCIbuffer;
+	void* mCamRecSetting;
+	//CameraRecSetting mCamRecSetting;
+	bool volatile mPaused;
+	bool volatile mResumed;
+#endif
+
     CameraSource(const CameraSource &);
     CameraSource &operator=(const CameraSource &);
 };
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba92068..5ce0dd718 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -24,6 +24,9 @@
 #include <utils/Errors.h>
 
 #include <OMX_Video.h>
+#ifdef MTK_HARDWARE
+#include <ui/PixelFormat.h>
+#endif
 
 namespace android {
 
@@ -62,6 +65,13 @@ private:
     OMX_COLOR_FORMATTYPE mSrcFormat, mDstFormat;
     uint8_t *mClip;
 
+#ifdef MTK_HARDWARE
+    status_t convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst);
+    status_t convertYUV420PlanarToABGR8888(const BitmapParams &src, const BitmapParams &dst);
+    void dumpColorConverterData(const char * filepath, const void * buffer, size_t size,const char * propty);
+    bool SWYUVToRGBConversion(const BitmapParams &src, const BitmapParams &dst);
+    PixelFormat mPixelFormat;
+#endif
     uint8_t *initClip();
 
     status_t convertCbYCrY(
diff --git a/include/media/stagefright/MediaBuffer.h b/include/media/stagefright/MediaBuffer.h
index 5ab266f4c..b66dfe153 100644
--- a/include/media/stagefright/MediaBuffer.h
+++ b/include/media/stagefright/MediaBuffer.h
@@ -56,6 +56,9 @@ public:
 
     MediaBuffer(const sp<ABuffer> &buffer);
 
+#ifdef MTK_HARDWARE
+    MediaBuffer(size_t size, sp<MetaData> metaData);
+#endif
     // Decrements the reference count and returns the buffer to its
     // associated MediaBufferGroup if the reference count drops to 0.
     virtual void release();
@@ -120,6 +123,12 @@ private:
     MediaBuffer(const MediaBuffer &);
     MediaBuffer &operator=(const MediaBuffer &);
 };
+#ifdef MTK_HARDWARE
+class MediaBufferSimpleObserver: public MediaBufferObserver {
+public:
+    virtual void signalBufferReturned(MediaBuffer *buffer);
+};
+#endif
 
 }  // namespace android
 
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index bab6432ce..bb4ddb0a5 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -41,6 +41,9 @@ namespace android {
 
 extern const char *MEDIA_MIMETYPE_IMAGE_JPEG;
 
+#ifdef MTK_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
+#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_VP8;
 extern const char *MEDIA_MIMETYPE_VIDEO_VP9;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index f7e013df6..b24fe0e0e 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -76,6 +76,16 @@ enum {
     INFO_DOLBY_PROCESSED_AUDIO_START = MEDIA_ERROR_BASE - 15,
     INFO_DOLBY_PROCESSED_AUDIO_STOP = MEDIA_ERROR_BASE - 16,
 #endif // DOLBY_END
+#ifdef MTK_HARDWARE
+    FAKE_INFO_DISCONTINUITY     = MEDIA_ERROR_BASE - 20,
+    ERROR_FORBIDDEN        = MEDIA_ERROR_BASE - 100 - 0,
+    ERROR_POOR_INTERLACE   = MEDIA_ERROR_BASE - 100 - 1,
+    INFO_TRY_READ_FAIL	   = MEDIA_ERROR_BASE - 100 - 2,
+    ERROR_UNSUPPORTED_VIDEO= MEDIA_ERROR_BASE - 100 - 3,
+    ERROR_UNSUPPORTED_AUDIO= MEDIA_ERROR_BASE - 100 - 4,
+    ERROR_EOS_QUITNOW       = MEDIA_ERROR_BASE - 100 - 5,
+    ERROR_BUFFER_DEQUEUE_FAIL = MEDIA_ERROR_BASE - 100 - 6,
+#endif
 
     // The following constant values should be in sync with
     // drm/drm_framework_common.h
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 3ac567aca..e1b641263 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -149,6 +149,60 @@ enum {
     kKeyWMVVersion        = 'wmvv',  // int32_t
     kKeyRVVersion         = '#rvv',  // int32_t
     kKeyBlockAlign        = 'blk',   // int32_t , should be different from kKeyWMABlockAlign
+#ifdef MTK_HARDWARE
+	kKeyIsLivePhoto 	  = 'islp',  //int32_t
+    kKeyVideoPreCheck	  = 'vpck',	 //int32_t(bool)
+    kKeyAudioPadEnable	  = 'apEn',	 //int32_t(bool),hai.li
+    kKeyMaxQueueBuffer    = 'mque',  //int32_t, Demon Deng for OMXCodec
+    kKeyAacObjType         = 'aaco',    // Morris Yang for MPEG4 audio object type
+    kKeySDP               = 'ksdp',  //int32_t, Demon Deng for SDP
+    kKeyUri					='kuri',//int32_t,haizhen for sdp
+    kKeyRvActualWidth     =  'rvaw', // int32_t, Morris Yang for RV
+    kKeyRvActualHeight    =  'rvah', // int32_t, Morris Yang for RV
+    kKeyServerTimeout     = 'srvt',  //int32_t, Demon Deng for RTSP Server timeout
+    kKeyIs3gpBrand		  = '3gpB',  //int32_t(bool), hai.li
+    kKeyIsQTBrand		  = 'qtBd',  //int32_t(bool), hai.li
+    kKeyFirstSampleOffset = 'FSOf',  //int64_t, hai.li
+    kKeyLastSampleOffset  = 'FSOl',  //int64_t, hai.li
+    kKeyMPEG4VOS			  = 'MP4C',  //raw data, hai.li for other container support mpeg4 codec
+    kKeyRTSPSeekMode      = 'rskm',  //int32_t, Demon Deng for RTSP Seek Mode
+    kKeyInputBufferNum    = 'inbf',  //int32_t, Demon Deng for OMXCodec
+    kKeyOutputBufferNum   = 'onbf',  //int32_t,for VE
+    kKeyHasUnsupportVideo = 'UnSV',  //int32_t(bool), hai.li, file has unsupport video track.
+    kKeyRTPTarget         = 'rtpt',  //int32_t, Demon Deng for ARTPWriter
+    kKeyCodecInfoIsInFirstFrame = 'CIFF', //int32(bool), hai.li,codec info is in the first frame 
+    kKeyCamMemInfo        = 'CMIf',  // int32_t, Morris Yang for OMXVEnc With Camera 
+    kKeyCamMCIMemInfo = 'CMCI', // pointer,, Morris Yang for Camera MCI mem info 
+    kKeyCamMCIMemSecurity ='CMSE',// int32_t, haizhen, for Camera MCI mem security info
+    kKeyCamMCIMemCoherent = 'CMCH', //int32_t,haizhen,for Camera MCI mem coherent info
+    //kKeyVecCamBufInfo	  = 'CMBI',  //pointer,haizhen for 89 cam buffer vector
+	kKeyCamMemMode        = 'CMMd', //add by haizhen for 89 cam Buffer mode
+	kKeyCamMemVaArray	  = 'CMAr',// add by haizhen for 89 cam buffer
+	kKeyCamMemIonFdArray  = 'CMIa', //add by haizhen for 89 ion cam buffer
+    kKeyCamWhiteboardEffect = 'CWEf',  // int32_t, Morris Yang for camera whiteboard effect (need to modify QP value for bitstream size)
+    kKeyCamMemVa		  = 'CMVa',	 //int32_t, camera yuv buffer virtual address
+    kKeyCamMemSize		  = 'CMSz',  //int32_t, camera yuv buffer size
+    kKeyCamMemCount		  = 'CMCt',  //int32_t, camera yuv buffer count
+    kKeyColorEffect		= 'CoEf',//cstring, camera color effect mode
+    kKeyAspectRatioWidth          =  'aspw',
+    kKeyAspectRatioHeight         =  'asph',
+    kKeyHLSVideoFirestRender   = 'v1Rn', //int64, timestamp, http live
+//    kKeyOutBufSize        = 'inbuf',//int32_t,for OMX Output Buffer Size
+    kKeyFrameNum          = 'frnu',//int32_t,for mp3 output buffer frame limit.
+    kKeySamplesperframe      = 'sapf', // int32_t samples per frame
+    kKeyRTSPOutputTimeoutUS = 'rsto',	// int64_t, omx output buf timeout for rtsp in US
+    kKeyHTTPOutputTimeoutUS = 'htpo',	// int64_t, omx output buf timeout for http in US
+    kKeyIsHTTPStreaming = 'htst',	// for omxcodec use
+//    kKeyWFDUseBufferPointer = 'usebufferpointer',
+//    kKeyWFDUseExternalDisplay = 'useexternaldisplay',
+    KKeyMultiSliceBS      = 'NalM',  //int32_t (bool), to indicate multi-slice Stream
+//	kKeyIsFromMP3Extractor = 'isFromMP3Extractor',
+//    kKeyTimeToSampleNumberEntry  = 'ttsne',  // int32_t
+//    kKeyTimeScaleOptional     = 'timesclop',  // int32_t
+//    kKeyTimeToSampleTable  = 'ttst',  // int32_t
+//    kKeySampleCount     = 'samplecnt',  // int32_t
+    kKeyRequiresMaxFBuffers = 'maxfb',  // bool (int32_t)
+#endif
 
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
@@ -163,7 +217,23 @@ enum {
 
     kKeyIsADTS            = 'adts',  // bool (int32_t)
     kKeyAACAOT            = 'aaot',  // int32_t
-
+#ifdef MTK_HARDWARE
+	kKeyCodecConfigInfo    = 'cinf',  // raw data
+	kkeyOmxTimeSource      = 'omts', 
+    kKeySupportTryRead     = 'tryR', //in32_t try read is supported
+	kKeyIsAACADIF		   = 'adif',  // int32_t (bool)
+	kKeyDataSourceObserver = 'dsob',	  //pointer, pointer of awesomeplayer weiguo
+	kKeyHasSEIBuffer	  = 'SEIB', //bool (int32_t)
+	kKeyVideoBitRate      = 'vbrt',// int32_t VR video Bitrate
+	kKeyVideoEncoder	  = 'venc', //int32_t VR encoder type refer MediaProfie.h
+	kKeyVQForMem 			= 'vqfm',  		// bool (int32_t)
+	kKeyVQForTemp 			= 'vqft',  		// bool (int32_t)
+//	kKeyHVCC				= 'hvcc',
+    kInvalidKeyTime         = 'invt',
+
+    kKeyVideoEditorVa   = 'VEVA',  // pointer
+    kKeyVideoEditorPa   = 'VEPA',  // pointer
+#endif
     // If a MediaBuffer's data represents (at least partially) encrypted
     // data, the following fields aid in decryption.
     // The data can be thought of as pairs of plain and encrypted data
@@ -210,6 +280,13 @@ enum {
     kTypeHVCC        = 'hvcc',
     kTypeD263        = 'd263',
 };
+#ifdef MTK_HARDWARE
+enum camera_mem_mode{
+	CAMERA_CONTINUOUS_MEM_MODE = 0, //camera mem is continus for 77
+	CAMERA_DISCONTINUOUS_MEM_VA_MODE = 1, //camera mem is discontinus for 89
+	CAMERA_DISCONTINUOUS_MEM_ION_MODE = 2,//camera mem is discontinus for 89--ion mem
+};
+#endif
 
 enum {
     kTypeDivXVer_3_11,
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index b57b49131..4f8e99944 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -45,6 +45,13 @@
 
 #include <OMX_Audio.h>
 
+#ifdef MTK_HARDWARE
+#include <binder/MemoryHeapBase.h>
+// adb shell property flags
+#define OMXCODEC_ENABLE_VIDEO_INPUT_ERROR_PATTERNS  (1 << 0)
+#define OMXCODEC_THUMBNAIL_MODE                     (1 << 1)
+#endif
+
 #include <media/stagefright/ExtendedStats.h>
 
 #define PLAYER_STATS(func, ...) \
@@ -88,6 +95,11 @@ struct OMXCodec : public MediaSource,
 
         // Secure decoding mode
         kUseSecureInputBuffers = 256,
+#ifdef MTK_HARDWARE
+        kUseMaxOutputBuffers = 2048,
+        kUseClearMotion = 4096,
+        kUsePostProcessingFw = 16384,
+#endif
     };
     static sp<MediaSource> Create(
             const sp<IOMX> &omx,
@@ -106,6 +118,22 @@ struct OMXCodec : public MediaSource,
 
     virtual sp<MetaData> getFormat();
 
+#ifdef MTK_HARDWARE
+    virtual sp<MetaData> getCameraMeta();
+    status_t vEncSetForceIframe(bool enable);
+    status_t vDecSwitchBwTVout(bool enable);
+
+    status_t vEncSetFrameRate(unsigned int u4FrameRate);
+    status_t vEncSetBitRate(unsigned int u4BitRate);
+    sp<MediaSource> getSource() { return mSource; }
+
+    enum MtkEncScenario {
+        kCameraRecord = 1,
+        kLivePhotoCapture = 2,
+        kLivePhotoEffect = 4,
+    };
+    status_t vEncSetSenario(MtkEncScenario eScenario);
+#endif
     virtual status_t read(
             MediaBuffer **buffer, const ReadOptions *options = NULL);
 
@@ -128,6 +156,10 @@ struct OMXCodec : public MediaSource,
         kSupportsMultipleFramesPerInputBuffer = 1024,
         kRequiresLargerEncoderOutputBuffer    = 2048,
         kOutputBuffersAreUnreadable           = 4096,
+#ifdef MTK_HARDWARE
+        kAvoidMemcopyInputRecordingFrames     = 8192,
+        kDecoderNeedPrebuffer                 = 16384,        
+#endif
         kRequiresGlobalFlush                  = 0x20000000, // 2^29
         kRequiresWMAProComponent              = 0x40000000, //2^30
     };
@@ -155,6 +187,17 @@ struct OMXCodec : public MediaSource,
             const CodecProfileLevel& defaultProfileLevel,
             CodecProfileLevel& profileLevel);
 
+#ifdef MTK_HARDWARE
+    	size_t buffersOwn();
+	void resume();
+
+    //for videoeditor MVA mode
+    void *findInputBufferByDataNumber(OMX_U32 portIndex, uint32_t number);
+
+    // Added for video editor to query the number of empty input buffers.
+    uint32_t getEmptyInputBufferCount();
+#endif
+
 protected:
     virtual ~OMXCodec();
 
@@ -232,6 +275,10 @@ private:
     char *mMIME;
     char *mComponentName;
     sp<MetaData> mOutputFormat;
+#ifdef MTK_HARDWARE
+    sp<MetaData> mCameraMeta;
+    bool mIsHttpStreaming;
+#endif
     sp<MediaSource> mSource;
     Vector<CodecSpecificData *> mCodecSpecificData;
     size_t mCodecSpecificDataIndex;
@@ -263,7 +310,26 @@ private:
     bool mDolbyProcessedAudio;
     bool mDolbyProcessedAudioStateChanged;
 #endif // DOLBY_END
-
+#ifdef MTK_HARDWARE
+    bool mIsVideoDecoder;
+    bool mIsVideoEncoder;
+    unsigned char* mInputBufferPoolMemBase;
+    unsigned char* mOutputBufferPoolMemBase;
+    sp<MemoryHeapBase> mMemHeapBase;
+    uint32_t mPropFlags;
+    float mVideoInputErrorRate;
+    Condition mBufferSent;
+    // set this by calling start with kKeyMaxQueueBuffer in meta
+    size_t mMaxQueueBufferNum;
+    bool mQueueWaiting;
+    bool mSupportsPartialFrames;
+    MediaBufferSimpleObserver mOMXPartialBufferOwner;
+    int32_t mVideoAspectRatioWidth;
+    int32_t mVideoAspectRatioHeight;
+    bool mIsVENCTimelapseMode;
+    int64_t mRTSPOutputTimeoutUS;
+    int64_t mHTTPOutputTimeoutUS;
+#endif
     sp<ANativeWindow> mNativeWindow;
 
     // The index in each of the mPortBuffers arrays of the buffer that will be
@@ -353,6 +419,10 @@ private:
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
 #ifdef USE_SAMSUNG_COLORFORMAT
     void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
+#endif
+#ifdef MTK_HARDWARE
+    status_t allocateBuffersOnInputPort();
+    status_t allocateBuffersOnOutputPort();
 #endif
     status_t allocateOutputBuffersFromNativeWindow();
 
@@ -366,15 +436,26 @@ private:
 
     status_t freeBuffer(OMX_U32 portIndex, size_t bufIndex);
 
+#ifndef MTK_HARDWARE
+    void PutErrorPatterns(uint8_t *pBuffer, uint32_t length);
+#endif
     bool drainInputBuffer(IOMX::buffer_id buffer);
     void fillOutputBuffer(IOMX::buffer_id buffer);
+#ifndef MTK_HARDWARE
+    bool drainInputBuffer(BufferInfo *info, bool init = false);
+#else
     bool drainInputBuffer(BufferInfo *info);
+#endif
     void fillOutputBuffer(BufferInfo *info);
 
     void drainInputBuffers();
     void fillOutputBuffers();
 
+#ifndef MTK_HARDWARE
+    bool drainAnyInputBuffer(bool init = false);
+#else
     bool drainAnyInputBuffer();
+#endif
     BufferInfo *findInputBufferByDataPointer(void *ptr);
     BufferInfo *findEmptyInputBuffer();
 
@@ -407,6 +488,9 @@ private:
     void dumpPortStatus(OMX_U32 portIndex);
 
     status_t configureCodec(const sp<MetaData> &meta);
+#ifdef MTK_HARDWARE
+    void restorePatchedDataPointer(BufferInfo *info);
+#endif
 
     status_t applyRotation();
     status_t waitForBufferFilled_l();
@@ -429,6 +513,10 @@ private:
     int32_t mNumBFrames;
     bool mInSmoothStreamingMode;
     bool mOutputCropChanged;
+#ifdef MTK_HARDWARE
+private:
+	int64_t mPreRollStartTime;
+#endif
 };
 
 struct CodecCapabilities {
@@ -472,7 +560,30 @@ status_t QueryCodec(
         CodecCapabilities *caps);
 
 status_t getOMXChannelMapping(size_t numChannels, OMX_AUDIO_CHANNELTYPE map[]);
+#ifdef MTK_HARDWARE
+#define VDOBUFCOUNT_MAX 16
+typedef struct
+{
+    uint32_t u4VdoBufCount;
+    uint32_t u4VdoBufSize;
+    uint32_t u4VdoBufVA[VDOBUFCOUNT_MAX];
+} CamMemInfo_t;
+
+typedef struct
+{
+    uint32_t u4VdoBufCount;
+    uint32_t u4VdoBufSize;
+    int          IonFd[VDOBUFCOUNT_MAX];
+    uint32_t u4VdoBufVA[VDOBUFCOUNT_MAX];
+} CamMemIonInfo_t;
+
+typedef struct
+{
+    uint32_t u4Security;
+    uint32_t u4Coherent;
+} CamMCIMemInfo_t;
 
+#endif
 }  // namespace android
 
 #endif  // OMX_CODEC_H_
diff --git a/include/media/stagefright/SurfaceMediaSource.h b/include/media/stagefright/SurfaceMediaSource.h
index d15a22672..223ec6b9a 100644
--- a/include/media/stagefright/SurfaceMediaSource.h
+++ b/include/media/stagefright/SurfaceMediaSource.h
@@ -234,6 +234,29 @@ private:
 
     // Avoid copying and equating and default constructor
     DISALLOW_IMPLICIT_CONSTRUCTORS(SurfaceMediaSource);
+#ifdef MTK_HARDWARE
+    void drainBufferQueue();
+    void dumpBuffer();
+
+    // for continuous buffers dump
+    int mContBufsDumpById;
+    uint32_t mBackupBufsIndex;
+    uint32_t mBackupBufsMax; 
+    Vector< sp<GraphicBuffer> > mBackBufs;
+
+    void dumpSingleBuffer();
+    void dumpGraphicBuffer(sp<GraphicBuffer> buf, int index);
+    void backupProcess(void* dst, void* src, size_t size);
+
+    bool mIsBinderDied;
+
+public:
+    status_t binderDied();
+
+    // for continuous buffers dump
+    void dumpContinuousBuffer();
+    virtual void activeBufferBackup();
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index 73157bb7e..6a53cb16a 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -22,6 +22,9 @@ endif
 
 include $(CLEAR_VARS)
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_CFLAGS += -DMTK_MT6589
+endif
 LOCAL_SRC_FILES:= \
     AudioTrack.cpp \
     AudioTrackShared.cpp \
@@ -114,6 +117,16 @@ LOCAL_STATIC_LIBRARIES += libinstantssq
 
 LOCAL_WHOLE_STATIC_LIBRARIES := libmedia_helper
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_STATIC_LIBRARIES += \
+        libmedia_helper
+LOCAL_SHARED_LIBRARIES += \
+        libvcodecdrv
+
+LOCAL_C_INCLUDES += \
+    $(TOP)/mediatek/platform/mt6589/hardware/vcodec/inc
+endif
+
 LOCAL_MODULE:= libmedia
 
 LOCAL_C_INCLUDES := \
@@ -125,6 +138,14 @@ LOCAL_C_INCLUDES := \
     $(call include-path-for, audio-effects) \
     $(call include-path-for, audio-utils)
 
+ifeq ($(MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+    mtkaudio_stubs.cpp
+
+# StrongPointer.h
+LOCAL_C_INCLUDES += $(TOP)/frameworks/rs/server
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 9cae21c68..50528b859 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -965,6 +965,29 @@ status_t AudioSystem::registerPolicyMixes(Vector<AudioMix> mixes, bool registrat
     return aps->registerPolicyMixes(mixes, registration);
 }
 
+#ifdef MTK_HARDWARE
+status_t AudioSystem::SetAudioData(int par1,size_t byte_len,void *ptr) {
+     ALOGD("SetAudioData");
+     const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+     if (af == 0)
+     {
+         ALOGE("AudioSystem::SetAAudioData Error!! PERMISSION_DENIED");
+         return PERMISSION_DENIED;
+     }
+     return af->SetAudioData(par1,byte_len,ptr);
+}
+
+status_t AudioSystem::GetAudioData(int par1,size_t byte_len,void *ptr) {
+     ALOGD("GetAudioData");
+     const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+     if (af == 0) {
+         ALOGE("AudioSystem::GetAAudioData Error!! PERMISSION_DENIED");
+         return PERMISSION_DENIED;
+     }
+     return af->GetAudioData(par1,byte_len,ptr);
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 void AudioSystem::AudioPolicyServiceClient::binderDied(const wp<IBinder>& who __unused)
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index dcaaf9dc3..814c08c4b 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -1752,6 +1752,7 @@ void AudioTrack::releaseBuffer(Buffer* audioBuffer)
 
 // -------------------------------------------------------------------------
 
+ssize_t AudioTrack::write(const void* buffer, size_t userSize) { return this->write(buffer, userSize, true); }
 ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)
 {
 #ifdef QCOM_DIRECTTRACK
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 3f76506a2..42f92679f 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -85,6 +85,10 @@ enum {
 #ifdef QCOM_DIRECTTRACK
     CREATE_DIRECT_TRACK,
 #endif
+#ifdef MTK_HARDWARE
+	SET_AUDIO_DATA,
+	GET_AUDIO_DATA,
+#endif
 };
 
 #define MAX_ITEMS_PER_LIST 1024
@@ -944,6 +948,32 @@ public:
         }
         return (audio_hw_sync_t)reply.readInt32();
     }
+
+#ifdef MTK_HARDWARE
+    virtual status_t SetAudioData(int par1, size_t len,void *ptr)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(SET_AUDIO_DATA, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+    virtual status_t GetAudioData(int par1, size_t len,void *ptr)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(GET_AUDIO_DATA, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+#endif
+
 };
 
 IMPLEMENT_META_INTERFACE(AudioFlinger, "android.media.IAudioFlinger");
@@ -1465,6 +1495,32 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(getAudioHwSyncForSession((audio_session_t)data.readInt32()));
             return NO_ERROR;
         } break;
+#ifdef MTK_HARDWARE
+        case SET_AUDIO_DATA:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            void *params = malloc(buf_size);
+            data.read(params, buf_size);
+            status_t err = SetAudioData(command,buf_size,params);
+            reply->write(params,buf_size);
+            free(params);
+            return NO_ERROR;
+        }break;
+        case GET_AUDIO_DATA:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            void *params = malloc(buf_size);
+            data.read(params, buf_size);
+            status_t err = GetAudioData(command,buf_size,params);
+            reply->write(params,buf_size);
+            free(params);
+            return NO_ERROR;
+        }break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
index 56c8f3d29..d4953004f 100644
--- a/media/libmedia/IAudioPolicyService.cpp
+++ b/media/libmedia/IAudioPolicyService.cpp
@@ -70,7 +70,11 @@ enum {
     ACQUIRE_SOUNDTRIGGER_SESSION,
     RELEASE_SOUNDTRIGGER_SESSION,
     GET_PHONE_STATE,
-    REGISTER_POLICY_MIXES,
+    REGISTER_POLICY_MIXES
+#ifdef MTK_HARDWARE
+    ,
+    SET_POLICYMANAGER_PARAMETERS
+#endif
 };
 
 #define MAX_ITEMS_PER_LIST 1024
@@ -492,6 +496,20 @@ public:
         return status;
     }
 
+#ifdef MTK_HARDWARE
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(par2);
+        data.writeInt32(par3);
+        data.writeInt32(par4);
+        remote()->transact(SET_POLICYMANAGER_PARAMETERS, data, &reply);
+        return static_cast <status_t> (reply.readInt32());
+    }
+#endif
+
     virtual bool isOffloadSupported(const audio_offload_info_t& info)
     {
         Parcel data, reply;
@@ -1042,6 +1060,18 @@ status_t BnAudioPolicyService::onTransact(
             return status;
         }
 
+#ifdef MTK_HARDWARE
+        case SET_POLICYMANAGER_PARAMETERS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int par1 =data.readInt32();
+            int par2 =data.readInt32();
+            int par3 =data.readInt32();
+            int par4 =data.readInt32();
+            reply->writeInt32(SetPolicyManagerParameters(par1,par2,par3,par4));
+            return NO_ERROR;
+        } break;
+#endif
+
         case IS_OFFLOAD_SUPPORTED: {
             CHECK_INTERFACE(IAudioPolicyService, data, reply);
             audio_offload_info_t info;
diff --git a/media/libmedia/IOMX.cpp b/media/libmedia/IOMX.cpp
index be39f3ee3..d2a19312e 100644
--- a/media/libmedia/IOMX.cpp
+++ b/media/libmedia/IOMX.cpp
@@ -57,6 +57,13 @@ enum {
     SET_INTERNAL_OPTION,
     UPDATE_GRAPHIC_BUFFER_IN_META,
     CONFIGURE_VIDEO_TUNNEL_MODE,
+#ifdef MTK_HARDWARE
+    USE_BUFFER2,
+    USE_BUFFER3,
+    REGISTER_BUFFER,
+    REGISTER_BUFFER2,
+    USE_ION_BUFFER,
+#endif
 };
 
 class BpOMX : public BpInterface<IOMX> {
@@ -355,6 +362,105 @@ public:
         return err;
     }
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) {
+
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeInt32(size);
+        remote()->transact(USE_BUFFER2, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) {
+
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeInt32(size);
+        data.writeInt32(offset);
+        remote()->transact(USE_BUFFER3, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeStrongBinder(heap->asBinder());
+        remote()->transact(REGISTER_BUFFER, data, &reply);
+
+        return reply.readInt32();
+    }
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeStrongBinder(HeapBase->asBinder());
+        remote()->transact(REGISTER_BUFFER2, data, &reply);
+
+        return reply.readInt32();
+    }
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeFileDescriptor((OMX_S32)fd);
+        data.writeInt32(size);
+        ALOGV("useIonBuffer writeFileDescriptor %x, %x, %x, %x, %x", node, port_index, virAddr, fd, size);
+        remote()->transact(USE_ION_BUFFER, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+#endif
+
     virtual status_t prepareForAdaptivePlayback(
             node_id node, OMX_U32 port_index, OMX_BOOL enable,
             OMX_U32 max_width, OMX_U32 max_height) {
@@ -855,6 +961,96 @@ status_t BnOMX::onTransact(
 
             return NO_ERROR;
         }
+#ifdef MTK_HARDWARE
+        case USE_BUFFER2:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            size_t size = data.readInt32();
+            buffer_id buffer;
+            status_t err = useBuffer(node, port_index, virAddr, size, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+
+        case USE_BUFFER3:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            size_t size = data.readInt32();
+            OMX_U32 offset = data.readInt32();
+            buffer_id buffer;
+            status_t err = useBuffer(node, port_index, virAddr, size, offset, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+
+        case REGISTER_BUFFER:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            sp<IMemoryHeap> heap =
+                interface_cast<IMemoryHeap>(data.readStrongBinder());
+
+            status_t err = registerBuffer(node, port_index, heap);
+            reply->writeInt32(err);
+
+            return NO_ERROR;
+        }
+
+    case REGISTER_BUFFER2:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            sp<IMemoryHeap> HeapBase =
+                interface_cast<IMemoryHeap>(data.readStrongBinder());
+
+            status_t err = registerBuffer2(node, port_index, HeapBase);
+            reply->writeInt32(err);
+
+            return NO_ERROR;
+        }
+        case USE_ION_BUFFER:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            OMX_S32 fd = dup(data.readFileDescriptor());
+            size_t size = data.readInt32();
+            ALOGV("useIonBuffer readFileDescriptor %x, %x, %x, %x, %x", node, port_index, virAddr, fd, size);
+            buffer_id buffer;
+            status_t err = useIonBuffer(
+                    node, port_index, virAddr, fd, size, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+#endif
 
         case PREPARE_FOR_ADAPTIVE_PLAYBACK:
         {
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index 5648a7de7..53e5a4e1f 100755
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -28,6 +28,16 @@
 #include <media/stagefright/foundation/ADebug.h>
 #include <OMX_Video.h>
 #include <OMX_VideoExt.h>
+#ifdef MTK_HARDWARE
+#include "venc_drv_if.h"
+#include "val_types.h"
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+//for devinfo
+#define DEV_IOC_MAGIC       'd'
+#define READ_DEV_DATA       _IOR(DEV_IOC_MAGIC,  1, unsigned int)
+#endif
 
 namespace android {
 
@@ -696,24 +706,56 @@ MediaProfiles::getInstance()
     return sInstance;
 }
 
+#ifdef MTK_HARDWARE
+static int getVideoCapability(int i4VideoFormat,unsigned int *pu4Width, unsigned int *pu4Height, unsigned int *pu4BitRatem, unsigned int *pu4FrameRate);
+#endif
+
 /*static*/ MediaProfiles::VideoEncoderCap*
 MediaProfiles::createDefaultH263VideoEncoderCap()
 {
     return new MediaProfiles::VideoEncoderCap(
+#ifdef MTK_HARDWARE
+        VIDEO_ENCODER_H263, 375*1000, 10000*1000, 176, 704, 144, 576, 15, 30, 0, 0, 0);
+#else
         VIDEO_ENCODER_H263, 192000, 420000, 176, 352, 144, 288, 1, 20, 0, 0, 0);
+#endif
 }
 
 /*static*/ MediaProfiles::VideoEncoderCap*
 MediaProfiles::createDefaultM4vVideoEncoderCap()
 {
+#ifdef MTK_HARDWARE
+    unsigned int u4Width, u4Height, u4FrameRate, u4BitRate;
+    if(getVideoCapability(VIDEO_ENCODER_MPEG_4_SP, &u4Width, &u4Height, &u4BitRate, &u4FrameRate ) > 0){
+        ALOGD("[ %s ], support maxwidth=%d,maxheight=%d, bitrate %d, framerate %d",__FUNCTION__,u4Width,u4Height, u4BitRate, u4FrameRate);
+    return new MediaProfiles::VideoEncoderCap(
+        VIDEO_ENCODER_MPEG_4_SP, 75*1000, u4BitRate, 96, u4Width, 96, u4Height, 15, 30, 0, 0, 0);
+    }
+    else{
+        return new MediaProfiles::VideoEncoderCap(
+            VIDEO_ENCODER_MPEG_4_SP, 75*1000, 12500*1000, 96, 1280, 96, 720, 15, 30, 0, 0 ,0);
+    }
+#else
     return new MediaProfiles::VideoEncoderCap(
         VIDEO_ENCODER_MPEG_4_SP, 192000, 420000, 176, 352, 144, 288, 1, 20, 0, 0, 0);
+#endif
 }
 
+#ifdef MTK_HARDWARE
+/*static*/ MediaProfiles::VideoEncoderCap*
+MediaProfiles::createDefaultH264VideoEncoderCap()
+{
+    return new MediaProfiles::VideoEncoderCap(
+        VIDEO_ENCODER_H264, 75000, 9000*1000, 96, 1280, 96, 720, 15, 30, 0, 0, 0);
+}
+#endif
 
 /*static*/ void
 MediaProfiles::createDefaultVideoEncoders(MediaProfiles *profiles)
 {
+#ifdef MTK_HARDWARE
+   profiles->mVideoEncoders.add(createDefaultH264VideoEncoderCap());
+#endif
     profiles->mVideoEncoders.add(createDefaultH263VideoEncoderCap());
     profiles->mVideoEncoders.add(createDefaultM4vVideoEncoderCap());
 }
@@ -739,8 +781,12 @@ MediaProfiles::createDefaultCamcorderTimeLapseQcifProfile(camcorder_quality qual
 MediaProfiles::createDefaultCamcorderTimeLapse480pProfile(camcorder_quality quality)
 {
     MediaProfiles::VideoCodec *videoCodec =
+#ifdef MTK_HARDWARE
+        new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 6000*1000, 640, 480, 20);//for front cam not support 720x480 in BSP case
+#else
         new MediaProfiles::VideoCodec(VIDEO_ENCODER_H263, 20000000, 720, 480, 20);
 
+#endif
     AudioCodec *audioCodec = new AudioCodec(AUDIO_ENCODER_AMR_NB, 12200, 8000, 1);
     CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
     profile->mCameraId = 0;
@@ -816,10 +862,317 @@ MediaProfiles::createDefaultCamcorderLowProfiles(
 MediaProfiles::createDefaultCamcorderHighProfiles(
         MediaProfiles::CamcorderProfile **highProfile,
         MediaProfiles::CamcorderProfile **highSpecificProfile) {
+#ifdef MTK_HARDWARE
+    *highProfile = createMTKCamcorderProfile(CAMCORDER_QUALITY_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    *highSpecificProfile = createMTKCamcorderProfile(CAMCORDER_QUALITY_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+#else
     *highProfile = createDefaultCamcorderCifProfile(CAMCORDER_QUALITY_HIGH);
     *highSpecificProfile = createDefaultCamcorderCifProfile(CAMCORDER_QUALITY_CIF);
+#endif
+}
+
+#ifdef MTK_HARDWARE
+/*static*/ MediaProfiles::CamcorderProfile*
+MediaProfiles::createDefaultCamcorderFrontQcifProfile(camcorder_quality quality)
+{
+	MediaProfiles::VideoCodec *videoCodec =
+		//new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, 192000, 176, 144, 20);
+		new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 192000, 176, 144, 20);
+
+    MediaProfiles::AudioCodec *audioCodec =
+        new MediaProfiles::AudioCodec(AUDIO_ENCODER_AMR_NB, 12200, 8000, 1);
+
+    MediaProfiles::CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
+    profile->mCameraId = 1;
+    profile->mFileFormat = OUTPUT_FORMAT_THREE_GPP;
+    profile->mQuality = quality;
+    profile->mDuration = 30;
+    profile->mVideoCodec = videoCodec;
+    profile->mAudioCodec = audioCodec;
+    return profile;
+}
+
+/*static*/ MediaProfiles::CamcorderProfile*
+MediaProfiles::createDefaultCamcorderFrontCifProfile(camcorder_quality quality)
+{
+    MediaProfiles::VideoCodec *videoCodec =
+        new MediaProfiles::VideoCodec(VIDEO_ENCODER_H263, 360000, 352, 288, 20);
+
+    AudioCodec *audioCodec = new AudioCodec(AUDIO_ENCODER_AMR_NB, 12200, 8000, 1);
+    CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
+    profile->mCameraId = 1;
+    profile->mFileFormat = OUTPUT_FORMAT_THREE_GPP;
+    profile->mQuality = quality;
+    profile->mDuration = 60;
+    profile->mVideoCodec = videoCodec;
+    profile->mAudioCodec = audioCodec;
+    return profile;
+}
+
+/*static*/ MediaProfiles::CamcorderProfile*
+MediaProfiles::createDefaultCamcorderFrontTimeLapseQcifProfile(camcorder_quality quality)
+{
+    MediaProfiles::VideoCodec *videoCodec =
+        new MediaProfiles::VideoCodec(VIDEO_ENCODER_H263, 1000000, 176, 144, 20);
+
+    AudioCodec *audioCodec = new AudioCodec(AUDIO_ENCODER_AMR_NB, 12200, 8000, 1);
+    CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
+    profile->mCameraId = 1;
+    profile->mFileFormat = OUTPUT_FORMAT_THREE_GPP;
+    profile->mQuality = quality;
+    profile->mDuration = 60;
+    profile->mVideoCodec = videoCodec;
+    profile->mAudioCodec = audioCodec;
+    return profile;
+}
+
+/*static*/ MediaProfiles::CamcorderProfile*
+MediaProfiles::createDefaultCamcorderFrontTimeLapse480pProfile(camcorder_quality quality)
+{
+    MediaProfiles::VideoCodec *videoCodec =
+        new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 6000*1000, 640, 480, 20);//for front cam not support 720x480 in BSP case
+
+    AudioCodec *audioCodec = new AudioCodec(AUDIO_ENCODER_AMR_NB, 12200, 8000, 1);
+    CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
+    profile->mCameraId = 1;
+    profile->mFileFormat = OUTPUT_FORMAT_THREE_GPP;
+    profile->mQuality = quality;
+    profile->mDuration = 30;
+    profile->mVideoCodec = videoCodec;
+    profile->mAudioCodec = audioCodec;
+    return profile;
+}
+
+/*static*/ void
+MediaProfiles::createDefaultCamcorderFrontLowProfiles(
+        MediaProfiles::CamcorderProfile **lowProfile,
+        MediaProfiles::CamcorderProfile **lowSpecificProfile) {
+    *lowProfile = createDefaultCamcorderFrontQcifProfile(CAMCORDER_QUALITY_LOW);
+    *lowSpecificProfile = createDefaultCamcorderFrontQcifProfile(CAMCORDER_QUALITY_QCIF);
+}
+
+/*static*/ void
+MediaProfiles::createDefaultCamcorderFrontHighProfiles(
+        MediaProfiles::CamcorderProfile **highProfile,
+        MediaProfiles::CamcorderProfile **highSpecificProfile) {
+    *highProfile = createMTKCamcorderProfile(CAMCORDER_QUALITY_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+    *highSpecificProfile = createMTKCamcorderProfile(CAMCORDER_QUALITY_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+}
+/*static*/ void
+MediaProfiles::createDefaultCamcorderFrontTimeLapseLowProfiles(
+        MediaProfiles::CamcorderProfile **lowTimeLapseProfile,
+        MediaProfiles::CamcorderProfile **lowSpecificTimeLapseProfile) {
+    *lowTimeLapseProfile = createDefaultCamcorderFrontTimeLapseQcifProfile(CAMCORDER_QUALITY_TIME_LAPSE_LOW);
+    *lowSpecificTimeLapseProfile = createDefaultCamcorderFrontTimeLapseQcifProfile(CAMCORDER_QUALITY_TIME_LAPSE_QCIF);
 }
 
+/*static*/ void
+MediaProfiles::createDefaultCamcorderFrontTimeLapseHighProfiles(
+        MediaProfiles::CamcorderProfile **highTimeLapseProfile,
+        MediaProfiles::CamcorderProfile **highSpecificTimeLapseProfile) {
+    *highTimeLapseProfile = createDefaultCamcorderFrontTimeLapse480pProfile(CAMCORDER_QUALITY_TIME_LAPSE_HIGH);
+    *highSpecificTimeLapseProfile = createDefaultCamcorderFrontTimeLapse480pProfile(CAMCORDER_QUALITY_TIME_LAPSE_480P);
+}
+
+static int getVideoCapability(int i4VideoFormat,unsigned int *pu4Width, unsigned int *pu4Height, unsigned int *pu4BitRatem, unsigned int *pu4FrameRate)
+{
+    int i4RetValue = 1;
+    VENC_DRV_QUERY_VIDEO_FORMAT_T qinfo;
+    VENC_DRV_QUERY_VIDEO_FORMAT_T outinfo;
+    VENC_DRV_MRESULT_T ret;
+
+    if((NULL == pu4Width) || (NULL == pu4Height) || (NULL == pu4BitRatem) || (NULL == pu4FrameRate)){
+        return -1;
+    }
+
+    memset(&qinfo,0,sizeof(VENC_DRV_QUERY_VIDEO_FORMAT_T));
+    memset(&outinfo,0,sizeof(VENC_DRV_QUERY_VIDEO_FORMAT_T));
+    switch (i4VideoFormat)
+    {
+        /*
+        case VIDEO_ENCODER_H263 :
+            qinfo.eVideoFormat = VENC_DRV_VIDEO_FORMAT_H263;
+        break;*/
+
+        case VIDEO_ENCODER_H264 :
+            qinfo.eVideoFormat = VENC_DRV_VIDEO_FORMAT_H264;
+            ret = eVEncDrvQueryCapability(VENC_DRV_QUERY_TYPE_VIDEO_FORMAT, &qinfo, &outinfo);
+            if(ret ==  VENC_DRV_MRESULT_OK){
+                (*pu4Width)= outinfo.u4Width;
+                (*pu4Height) = outinfo.u4Height;
+                (*pu4BitRatem) = outinfo.u4Bitrate;
+                (*pu4FrameRate) = outinfo.u4FrameRate;
+                ALOGI("checkVideoCapability, format=%d,support maxwidth=%d,maxheight=%d, bitrate %d, framerate %d",i4VideoFormat,outinfo.u4Width,outinfo.u4Height, outinfo.u4Bitrate, outinfo.u4FrameRate);
+            }
+            else{
+                i4RetValue = -1;
+            }
+        break;
+        case VIDEO_ENCODER_MPEG_4_SP :
+            qinfo.eVideoFormat = VENC_DRV_VIDEO_FORMAT_MPEG4;
+            ret = eVEncDrvQueryCapability(VENC_DRV_QUERY_TYPE_VIDEO_FORMAT, &qinfo, &outinfo);
+            if(ret ==  VENC_DRV_MRESULT_OK){
+                (*pu4Width)= outinfo.u4Width;
+                (*pu4Height) = outinfo.u4Height;
+                (*pu4BitRatem) = outinfo.u4Bitrate;
+                (*pu4FrameRate) = outinfo.u4FrameRate;
+                ALOGI("checkVideoCapability, format=%d,support maxwidth=%d,maxheight=%d, bitrate %d, framerate %d",i4VideoFormat,outinfo.u4Width,outinfo.u4Height, outinfo.u4Bitrate, outinfo.u4FrameRate);
+            }
+            else{
+                i4RetValue = -1;
+            }
+        break;
+        default:
+            i4RetValue = -1;
+            break;
+    }
+     return i4RetValue;
+}
+
+/*static*/ MediaProfiles::CamcorderProfile*
+MediaProfiles::createMTKCamcorderProfile(camcorder_quality quality, camcorder_mode CamMode, camera_id CamId)
+{
+    MediaProfiles::VideoCodec *videoCodec = NULL;
+    MediaProfiles::AudioCodec *audioCodec = NULL;
+    int64_t memory_size_byte = (int64_t)sysconf(_SC_PHYS_PAGES) * PAGE_SIZE;
+    unsigned int u4Width, u4Height, u4FrameRate, u4BitRate;
+	unsigned int MEMORY_SIZE_IS_LARGE = 0;
+	if (memory_size_byte > 256*1024*1024)
+		MEMORY_SIZE_IS_LARGE = 1;
+	else
+		MEMORY_SIZE_IS_LARGE = 1;
+
+	// Setting for VIDEO Profile
+	switch(quality)
+	{
+		case CAMCORDER_QUALITY_MTK_LOW:
+		case CAMCORDER_QUALITY_MTK_NIGHT_LOW:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW:
+						if (CamId == BACK_CAMERA){
+							videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, 750*1000/CamMode, 176, 144, 30/CamMode);
+						}
+						else{
+							videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 150*1000/CamMode, 176, 144, 30/CamMode);
+						}
+			break;
+		case CAMCORDER_QUALITY_MTK_MEDIUM:
+		case CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM:
+#ifdef MTK_CAMCORDER_PROFILE_MID_MP4
+			if (CamId == BACK_CAMERA){
+				videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 4000*1000/CamMode, 480, 320, 30/CamMode);
+			}
+			else{
+				videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 2000*1000/CamMode, 480, 320, 30/CamMode);
+			 }
+#else
+				videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, (CamMode == CAMCORDER_DAY_MODE) ? 3000*1000 : 1250*1000, 640, 480, 30/CamMode);
+#endif
+			break;
+		case CAMCORDER_QUALITY_MTK_HIGH:
+		case CAMCORDER_QUALITY_MTK_NIGHT_HIGH:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH:
+						if (CamId == BACK_CAMERA){
+							videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, 9000*1000/CamMode, 1280, 720, 30/CamMode);
+						}
+						else{
+							videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 4200*1000/CamMode, 640, 480, 30/CamMode);
+						}
+			break;
+		case CAMCORDER_QUALITY_480P:   // just for CTS
+		case CAMCORDER_QUALITY_HIGH:   // just for CTS
+                        if (CamId == BACK_CAMERA){
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 6000*1000/CamMode, 640, 480, 30/CamMode);
+                        }
+                        else{
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 4200*1000/CamMode, 640, 480, 30/CamMode);
+                        }
+			break;
+		case CAMCORDER_QUALITY_MTK_FINE:
+		case CAMCORDER_QUALITY_MTK_NIGHT_FINE:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE:
+							if(getVideoCapability(VIDEO_ENCODER_MPEG_4_SP, &u4Width, &u4Height, &u4BitRate, &u4FrameRate ) > 0){
+								if((u4Width >= 1920) && (u4Height >= 1088)){
+									videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 26000*1000/CamMode, 1920, 1088, 30/CamMode);
+								}
+								else{
+									videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, (u4BitRate)/CamMode, u4Width, u4Height, u4FrameRate/CamMode);
+								}
+							}
+							else
+							{
+								ALOGD("[%s] Cannot get video capability use default",__FUNCTION__);
+								videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 26000*1000/CamMode, 1920, 1088, 30/CamMode);
+							}
+			break;
+		case CAMCORDER_QUALITY_MTK_LIVE_EFFECT:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT:
+                        if (CamId == BACK_CAMERA){
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 2500*1000/CamMode, 480, 320, 30/CamMode);
+                        }
+                        else{
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 2500*1000/CamMode, 480, 320, 30/CamMode);
+                        }
+                        break;
+		case CAMCORDER_QUALITY_MTK_H264_HIGH:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH:
+                        if (CamId == BACK_CAMERA){
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, 4000*1000/CamMode, 640, 480, 30/CamMode);
+                        }
+                        else{
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_H264, 4000*1000/CamMode, 640, 480, 30/CamMode);
+                        }
+                        break;
+		case CAMCORDER_QUALITY_MTK_MPEG4_1080P:
+		case CAMCORDER_QUALITY_MTK_TIME_LAPSE_MPEG4_1080P:
+                        if (CamId == BACK_CAMERA){
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 14000*1000/CamMode, 1920, 1088, 15/CamMode);
+                        }
+                        else{
+                            videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 14000*1000/CamMode, 1920, 1088, 15/CamMode);
+                        }
+                        break;
+		default:
+			videoCodec = new MediaProfiles::VideoCodec(VIDEO_ENCODER_MPEG_4_SP, 75*1000/CamMode, 96, 96, 30/CamMode);
+			ALOGE("The given quality %d is not found", quality);
+			break;
+	}
+
+    // Setting for AUDIO Profile
+	switch(quality)
+	{
+        case CAMCORDER_QUALITY_MTK_LOW:
+        case CAMCORDER_QUALITY_MTK_NIGHT_LOW:
+        case CAMCORDER_QUALITY_TIME_LAPSE_LOW:
+        case CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW:
+        case CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW:
+            audioCodec = new AudioCodec(AUDIO_ENCODER_AAC, 64000, 48000, 2);
+            break;
+
+        //Fine quality AAC HE
+        case CAMCORDER_QUALITY_MTK_FINE:
+                    audioCodec = new AudioCodec(AUDIO_ENCODER_AAC, 128000, 48000, 2);
+            break;
+
+        default:
+            audioCodec = new AudioCodec(AUDIO_ENCODER_AAC, 128000, 48000, 2);
+            break;
+	}
+
+    CamcorderProfile *profile = new MediaProfiles::CamcorderProfile;
+    profile->mCameraId = CamId;
+    profile->mFileFormat = OUTPUT_FORMAT_THREE_GPP;
+    profile->mQuality = quality;
+    profile->mDuration = 30;
+    profile->mVideoCodec = videoCodec;
+    profile->mAudioCodec = audioCodec;
+    return profile;
+}
+#endif
 /*static*/ void
 MediaProfiles::createDefaultCamcorderProfiles(MediaProfiles *profiles)
 {
@@ -847,10 +1200,305 @@ MediaProfiles::createDefaultCamcorderProfiles(MediaProfiles *profiles)
     profiles->mCamcorderProfiles.add(highTimeLapseProfile);
     profiles->mCamcorderProfiles.add(highSpecificTimeLapseProfile);
 
+#ifdef MTK_HARDWARE
+
+    // low camcorder profiles.
+    MediaProfiles::CamcorderProfile *frontlowProfile, *frontlowSpecificProfile;
+    createDefaultCamcorderFrontLowProfiles(&frontlowProfile, &frontlowSpecificProfile);
+    profiles->mCamcorderProfiles.add(frontlowProfile);
+    profiles->mCamcorderProfiles.add(frontlowSpecificProfile);
+
+    // high camcorder profiles.
+    MediaProfiles::CamcorderProfile* fronthighProfile, *fronthighSpecificProfile;
+    createDefaultCamcorderFrontHighProfiles(&fronthighProfile, &fronthighSpecificProfile);
+    profiles->mCamcorderProfiles.add(fronthighProfile);
+    profiles->mCamcorderProfiles.add(fronthighSpecificProfile);
+
+    // low camcorder time lapse profiles.
+    MediaProfiles::CamcorderProfile *frontlowTimeLapseProfile, *frontlowSpecificTimeLapseProfile;
+    createDefaultCamcorderFrontTimeLapseLowProfiles(&frontlowTimeLapseProfile, &frontlowSpecificTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(frontlowTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(frontlowSpecificTimeLapseProfile);
+
+    // high camcorder time lapse profiles.
+    MediaProfiles::CamcorderProfile *fronthighTimeLapseProfile, *fronthighSpecificTimeLapseProfile;
+    createDefaultCamcorderFrontTimeLapseHighProfiles(&fronthighTimeLapseProfile, &fronthighSpecificTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(fronthighTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(fronthighSpecificTimeLapseProfile);
+
+
+    // mtk low camcorder profiles.
+    MediaProfiles::CamcorderProfile *LowProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LOW, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *LowSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LOW, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    profiles->mCamcorderProfiles.add(LowProfile);
+    profiles->mCamcorderProfiles.add(LowSpecificProfile);
+
+	// mtk medium camcorder profiles.
+	MediaProfiles::CamcorderProfile *MediumProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_MEDIUM, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *MediumSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_MEDIUM, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(MediumProfile);
+	profiles->mCamcorderProfiles.add(MediumSpecificProfile);
+
+    // mtk high camcorder profiles.
+    MediaProfiles::CamcorderProfile *HighProfile =
+            createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *HighSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    profiles->mCamcorderProfiles.add(HighProfile);
+    profiles->mCamcorderProfiles.add(HighSpecificProfile);
+
+    // 480p camcorder profiles.
+    MediaProfiles::CamcorderProfile *Back480pProfile =
+            createMTKCamcorderProfile(CAMCORDER_QUALITY_480P, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *Back480pSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_480P, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    profiles->mCamcorderProfiles.add(Back480pProfile);
+    profiles->mCamcorderProfiles.add(Back480pSpecificProfile);
+
+    // mtk fine camcorder profiles.
+    MediaProfiles::CamcorderProfile *FineProfile =
+            createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_FINE, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *FineSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_FINE, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    profiles->mCamcorderProfiles.add(FineProfile);
+    profiles->mCamcorderProfiles.add(FineSpecificProfile);
+
+    // mtk h264 high camcorder profiles.
+    //MediaProfiles::CamcorderProfile *H264HighProfile =
+            //createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_H264_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	//MediaProfiles::CamcorderProfile *H264HighSpecificProfile =
+		    //createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_H264_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    //profiles->mCamcorderProfiles.add(H264HighProfile);
+    //profiles->mCamcorderProfiles.add(H264HighSpecificProfile);
+
+	// front low camcorder profiles.
+	MediaProfiles::CamcorderProfile *FrontLowProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LOW, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontLowSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LOW, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontLowProfile);
+	profiles->mCamcorderProfiles.add(FrontLowSpecificProfile);
+
+	// front high camcorder profiles.
+	MediaProfiles::CamcorderProfile *FrontHighProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontHighSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontHighProfile);
+	profiles->mCamcorderProfiles.add(FrontHighSpecificProfile);
+
+    // front 480p camcorder profiles.
+	MediaProfiles::CamcorderProfile *Front480pProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_480P, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *Front480pSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_480P, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(Front480pProfile);
+	profiles->mCamcorderProfiles.add(Front480pSpecificProfile);
+
+	// night low camcorder profiles.
+	MediaProfiles::CamcorderProfile *NightLowProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_LOW, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightLowSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_LOW, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightLowProfile);
+	profiles->mCamcorderProfiles.add(NightLowSpecificProfile);
+
+	// night medium camcorder profiles.
+	MediaProfiles::CamcorderProfile *NightMediumProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightMediumSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_MEDIUM, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightMediumProfile);
+	profiles->mCamcorderProfiles.add(NightMediumSpecificProfile);
+
+	// night high camcorder profiles.
+	MediaProfiles::CamcorderProfile *NightHighProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightHighSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightHighProfile);
+	profiles->mCamcorderProfiles.add(NightHighProfile);
+
+	// night fine camcorder profiles.
+	MediaProfiles::CamcorderProfile *NightFineProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_FINE, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightFineSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_FINE, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightFineProfile);
+	profiles->mCamcorderProfiles.add(NightFineProfile);
+
+
+	// front night low camcorder profiles.
+	MediaProfiles::CamcorderProfile *FrontNightLowProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_LOW, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontNightLowSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_LOW, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontNightLowProfile);
+	profiles->mCamcorderProfiles.add(FrontNightLowSpecificProfile);
+
+	// front night high camcorder profiles.
+	MediaProfiles::CamcorderProfile *FrontNightHighProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontNightHighSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontNightHighProfile);
+	profiles->mCamcorderProfiles.add(FrontNightHighSpecificProfile);
+
+// LIVE EFFECT Profiles
+// mtk live effect camcorder profiles.
+MediaProfiles::CamcorderProfile *LiveEffectProfile =
+        createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LIVE_EFFECT, CAMCORDER_DAY_MODE, BACK_CAMERA);
+MediaProfiles::CamcorderProfile *LiveEffectSpecificProfile =
+        createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LIVE_EFFECT, CAMCORDER_DAY_MODE, BACK_CAMERA);
+profiles->mCamcorderProfiles.add(LiveEffectProfile);
+profiles->mCamcorderProfiles.add(LiveEffectSpecificProfile);
+
+
+// front night high camcorder profiles.
+MediaProfiles::CamcorderProfile *LiveEffectFrontProfile =
+        createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LIVE_EFFECT, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+MediaProfiles::CamcorderProfile *LiveEffectFrontSpecificProfile =
+        createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_LIVE_EFFECT, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+profiles->mCamcorderProfiles.add(LiveEffectFrontProfile);
+profiles->mCamcorderProfiles.add(LiveEffectFrontSpecificProfile);
+
+
+// TIME LAPSE Profiles
+
+    // mtk low camcorder time lapse profiles.
+    MediaProfiles::CamcorderProfile *LowTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *LowTimeLapseSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW, CAMCORDER_DAY_MODE, BACK_CAMERA);
+    profiles->mCamcorderProfiles.add(LowTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(LowTimeLapseSpecificProfile);
+
+	// mtk medium camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *MediumTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *MediumTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_MEDIUM, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(MediumTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(MediumTimeLapseSpecificProfile);
+
+    // mtk high camcorder time lapse profiles.
+    MediaProfiles::CamcorderProfile *HighTimeLapseProfile =
+            createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *HighTimeLapseSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);;
+    profiles->mCamcorderProfiles.add(HighTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(HighTimeLapseSpecificProfile);
+
+    // mtk fine camcorder time lapse profiles.
+    MediaProfiles::CamcorderProfile *FineTimeLapseProfile =
+            createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *FineTimeLapseSpecificProfile =
+		    createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_FINE, CAMCORDER_DAY_MODE, BACK_CAMERA);;
+    profiles->mCamcorderProfiles.add(FineTimeLapseProfile);
+    profiles->mCamcorderProfiles.add(FineTimeLapseSpecificProfile);
+
+    // mtk h264 high camcorder time lapse profiles.
+    //MediaProfiles::CamcorderProfile *H264HighTimeLapseProfile =
+            //createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	//MediaProfiles::CamcorderProfile *H264HighTimeLapseSpecificProfile =
+		    //createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_H264_HIGH, CAMCORDER_DAY_MODE, BACK_CAMERA);;
+    //profiles->mCamcorderProfiles.add(H264HighTimeLapseProfile);
+    //profiles->mCamcorderProfiles.add(H264HighTimeLapseSpecificProfile);
+
+	// front low camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *FrontLowTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontLowTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LOW, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontLowTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(FrontLowTimeLapseSpecificProfile);
+
+	// front high camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *FrontHighTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontHighTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_HIGH, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontHighTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(FrontHighTimeLapseSpecificProfile);
+
+	// night low camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *NightLowTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightLowTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightLowTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(NightLowTimeLapseSpecificProfile);
+
+	// night medium camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *NightMediumTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightMediumTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_MEDIUM, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightMediumTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(NightMediumTimeLapseSpecificProfile);
+
+	// night high camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *NightHighTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightHighTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightHighTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(NightHighTimeLapseSpecificProfile);
+
+	// night fine camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *NightFineTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *NightFineTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_FINE, CAMCORDER_NIGHT_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(NightFineTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(NightFineTimeLapseSpecificProfile);
+
+        // live effect camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *LiveEffectTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	MediaProfiles::CamcorderProfile *LiveEffectTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT, CAMCORDER_DAY_MODE, BACK_CAMERA);
+	profiles->mCamcorderProfiles.add(LiveEffectTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(LiveEffectTimeLapseSpecificProfile);
+
+
+        // live effect camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *LiveEffectTimeLapseFrontProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *LiveEffectTimeLapseSpecificFrontProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_LIVE_EFFECT, CAMCORDER_DAY_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(LiveEffectTimeLapseFrontProfile);
+	profiles->mCamcorderProfiles.add(LiveEffectTimeLapseSpecificFrontProfile);
+
+
+	// front night low camcorder profiles.
+	MediaProfiles::CamcorderProfile *FrontNightLowTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontNightLowTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_LOW, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontNightLowTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(FrontNightLowTimeLapseSpecificProfile);
+
+	// front night high camcorder time lapse profiles.
+	MediaProfiles::CamcorderProfile *FrontNightHighTimeLapseProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	MediaProfiles::CamcorderProfile *FrontNightHighTimeLapseSpecificProfile =
+			createMTKCamcorderProfile(CAMCORDER_QUALITY_MTK_TIME_LAPSE_NIGHT_HIGH, CAMCORDER_NIGHT_MODE, FRONT_CAMERA);
+	profiles->mCamcorderProfiles.add(FrontNightHighTimeLapseProfile);
+	profiles->mCamcorderProfiles.add(FrontNightHighTimeLapseSpecificProfile);
+#endif
+
     // For emulator and other legacy devices which does not have a
     // media_profiles.xml file, We assume that the default camera id
     // is 0 and that is the only camera available.
     profiles->mCameraIds.push(0);
+#ifdef MTK_HARDWARE
+    profiles->mCameraIds.push(1);
+#endif
 }
 
 /*static*/ void
@@ -916,6 +1564,15 @@ MediaProfiles::createDefaultImageEncodingQualityLevels(MediaProfiles *profiles)
     levels->mLevels.add(80);
     levels->mLevels.add(90);
     profiles->mImageEncodingQualityLevels.add(levels);
+#ifdef MTK_HARDWARE
+    ALOGE("FrontCameraLevels Setting\n");
+    ImageEncodingQualityLevels *FrontCameraLevels = new ImageEncodingQualityLevels();
+    FrontCameraLevels->mCameraId = 1;
+    FrontCameraLevels->mLevels.add(70);
+    FrontCameraLevels->mLevels.add(80);
+    FrontCameraLevels->mLevels.add(90);
+    profiles->mImageEncodingQualityLevels.add(FrontCameraLevels);
+#endif
 }
 
 /*static*/ void
@@ -1161,6 +1818,33 @@ Vector<audio_decoder> MediaProfiles::getAudioDecoders() const
     }
     return decoders;  // copy out
 }
+#ifdef MTK_HARDWARE
+size_t  MediaProfiles::getCamcorderProfilesNum(int id)
+{
+	return mCamcorderProfiles.size();
+}
+
+String8  MediaProfiles::getCamcorderProfilesCaps(int id)
+{
+	char buff[256];
+	memset(buff,0,256);
+
+	for (size_t i = 0; i < mCamcorderProfiles.size();  ++i)
+	{
+        if (id == mCamcorderProfiles[i]->mCameraId)
+        {
+            char temp[10];
+            memset(temp,0,10);
+	   	    sprintf(temp,"%d,",mCamcorderProfiles[i]->mQuality);
+            strcat(buff,temp);
+        }
+	}
+
+    ALOGD("[getCamcorderProfilesCaps] mCameraId = %d, buff = %s", id, buff);
+
+    return String8(buff);
+}
+#endif
 
 int MediaProfiles::getCamcorderProfileIndex(int cameraId, camcorder_quality quality) const
 {
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 8f06c5588..e8d60b138 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -56,6 +56,17 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/native/include/media/openmax                  \
     $(TOP)/external/tremolo/Tremolo                                 \
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+     $(TOP)/mediatek/kernel/include/linux/vcodec \
+     $(TOP)/mediatek/frameworks-ext/av/media/libstagefright/include    \
+
+LOCAL_SHARED_LIBRARIES += libvcodecdrv
+
+LOCAL_SHARED_LIBRARIES += libmtkplayer
+
+endif
+
 LOCAL_MODULE:= libmediaplayerservice
 
 LOCAL_32_BIT_ONLY := true
diff --git a/media/libmediaplayerservice/MediaPlayerFactory.cpp b/media/libmediaplayerservice/MediaPlayerFactory.cpp
index 03fae9196..7ade1a481 100644
--- a/media/libmediaplayerservice/MediaPlayerFactory.cpp
+++ b/media/libmediaplayerservice/MediaPlayerFactory.cpp
@@ -35,6 +35,10 @@
 #include "nuplayer/NuPlayerDriver.h"
 #include <dlfcn.h>
 
+#ifdef MTK_HARDWARE
+#include "FMAudioPlayer.h"
+#endif
+
 namespace android {
 
 Mutex MediaPlayerFactory::sLock;
@@ -388,6 +392,24 @@ class TestPlayerFactory : public MediaPlayerFactory::IFactory {
     }
 };
 
+#ifdef MTK_HARDWARE
+class FMPlayerFactory : public MediaPlayerFactory::IFactory {
+  public:
+    virtual float scoreFactory(const sp<IMediaPlayer>& /*client*/,
+                               const char* url,
+                               float /*curScore*/) {
+        if(strncmp(url, "MEDIATEK://MEDIAPLAYER_PLAYERTYPE_FM", 36) == 0)
+           return 1.0;
+        return 0.0;
+    }
+
+    virtual sp<MediaPlayerBase> createPlayer() {
+        ALOGD("Create FM Player");
+        return new FMAudioPlayer();
+    }
+};
+#endif
+
 void MediaPlayerFactory::registerBuiltinFactories() {
     Mutex::Autolock lock_(&sLock);
 
@@ -399,6 +421,9 @@ void MediaPlayerFactory::registerBuiltinFactories() {
     registerFactory_l(new SonivoxPlayerFactory(), SONIVOX_PLAYER);
     registerFactory_l(new TestPlayerFactory(), TEST_PLAYER);
 
+#ifdef MTK_HARDWARE
+    registerFactory_l(new FMPlayerFactory(), FM_AUDIO_PLAYER);
+#endif
     const char* FACTORY_LIB           = "libdashplayer.so";
     const char* FACTORY_CREATE_FN     = "CreateDASHFactory";
 
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 90d4a2544..dcae69c20 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -64,6 +64,9 @@
 #include <media/stagefright/FMA2DPWriter.h>
 #include <QCMediaDefs.h>
 #endif
+#ifdef MTK_HARDWARE
+#include "venc_drv_if.h" // for MCI buffer 
+#endif
 
 #include "ARTPWriter.h"
 #include <cutils/properties.h>
@@ -93,6 +96,14 @@ StagefrightRecorder::StagefrightRecorder()
       mRecPaused(false) {
 
     ALOGV("Constructor");
+#ifdef MTK_HARDWARE
+	mCamMemInfo = NULL;
+	mCamMemIonInfo = NULL;
+	//for MCI buffer
+	mCamMCIMemInfo = NULL;
+	mSupportMCIbuffer = false;
+	mpLivePhotoSource = NULL;
+#endif
     reset();
 
     mRecorderExtendedStats = (RecorderExtendedStats *)ExtendedStats::Create(
@@ -101,6 +112,30 @@ StagefrightRecorder::StagefrightRecorder()
 
 StagefrightRecorder::~StagefrightRecorder() {
     ALOGV("Destructor");
+#ifdef MTK_HARDWARE
+	if (mCamMemInfo != NULL)
+	{
+		free(mCamMemInfo);
+		mCamMemInfo = NULL;
+	}
+	if(mCamMemIonInfo != NULL)
+	{
+		free(mCamMemIonInfo);
+		mCamMemIonInfo = NULL;
+	}
+	if(mCamMCIMemInfo != NULL)
+	{
+		free(mCamMCIMemInfo);
+		mCamMCIMemInfo = NULL;
+	}
+/*	
+	if( mSurfaceMediaSource!= NULL && mStarted) {
+		ALOGD("call SurfaceMediaSource binderDied in ~StagefrightRecorder +");
+		mSurfaceMediaSource->binderDied();
+		ALOGD("call SurfaceMediaSource binderDied in ~StagefrightRecorder -");
+	}
+*/
+#endif
     stop();
 
     if (mLooper != NULL) {
@@ -236,7 +271,15 @@ status_t StagefrightRecorder::setVideoEncoder(video_encoder ve) {
         return BAD_VALUE;
     }
 
-    mVideoEncoder = ve;
+    if (ve == VIDEO_ENCODER_DEFAULT) {
+#ifdef MTK_HARDWARE //In order to pass CTS test case for preview size: 320 x 240
+        mVideoEncoder = VIDEO_ENCODER_MPEG_4_SP;
+#else
+        mVideoEncoder = VIDEO_ENCODER_H263;
+#endif
+    } else {
+        mVideoEncoder = ve;
+    }
 
     return OK;
 }
@@ -1662,6 +1705,14 @@ status_t StagefrightRecorder::setupVideoEncoder(
             break;
     }
 
+	// force hw video encoder for camera
+    if (mVideoSource == VIDEO_SOURCE_CAMERA) {
+        AString mime;
+        CHECK(format->findString("mime", &mime));
+        mime.append("_cam");
+        format->setString("mime", mime);
+    }
+
     if (cameraSource != NULL) {
         sp<MetaData> meta = cameraSource->getFormat();
 
@@ -1672,8 +1723,127 @@ status_t StagefrightRecorder::setupVideoEncoder(
         CHECK(meta->findInt32(kKeySliceHeight, &sliceHeight));
         CHECK(meta->findInt32(kKeyColorFormat, &colorFormat));
 
+#ifdef MTK_HARDWARE
+    if (mVideoSource == VIDEO_SOURCE_CAMERA) {   // for live effect recording
+		int32_t iCamMemMode = -1;
+		int32_t camMemSize, camMemCount;
+		CHECK(meta->findInt32(kKeyCamMemSize, &camMemSize));
+		CHECK(meta->findInt32(kKeyCamMemCount, &camMemCount));
+		CHECK(meta->findInt32(kKeyCamMemMode, &iCamMemMode));
+		
+		format->setInt32("CMMd",iCamMemMode);
+
+		//for MCI buffer
+		if(mCamMCIMemInfo == NULL)
+			mCamMCIMemInfo= malloc(sizeof(CamMCIMemInfo_t));
+
+		CamMCIMemInfo_t* camMCIMemInfo = (CamMCIMemInfo_t*)mCamMCIMemInfo;
+		memset(camMCIMemInfo, 0, sizeof(CamMCIMemInfo_t));
+
+		meta->findInt32(kKeyCamMCIMemSecurity,(int32_t*)&(camMCIMemInfo->u4Security));
+		meta->findInt32(kKeyCamMCIMemCoherent,(int32_t*)&(camMCIMemInfo->u4Coherent));
+		format->setPointer("CMCI",mCamMCIMemInfo);	
+		
+		if(iCamMemMode == CAMERA_CONTINUOUS_MEM_MODE){
+			
+			int32_t camMemVa;
+			CHECK(meta->findInt32(kKeyCamMemVa, &camMemVa));
+			
+			if (mCamMemInfo == NULL) {
+				mCamMemInfo = malloc(sizeof(CamMemInfo_t));
+			}
+			CamMemInfo_t *camMemInfo = (CamMemInfo_t *)mCamMemInfo;
+			memset(camMemInfo, 0, sizeof(CamMemInfo_t));
+			camMemInfo->u4VdoBufCount = camMemCount;
+			camMemInfo->u4VdoBufSize = camMemSize;
+			ALOGD("camMemInfo.u4VdoBufCount=%d, camMemInfo.u4VdoBufSize=%d", camMemInfo->u4VdoBufCount, camMemInfo->u4VdoBufSize);
+
+			for (uint32_t i = 0; i < camMemInfo->u4VdoBufCount; i++)
+			{
+				camMemInfo->u4VdoBufVA[i] = camMemVa + camMemSize * i;//VA is continous
+				ALOGD("camMemInfo.u4VdoBufVA[%d]=%d", i, camMemInfo->u4VdoBufVA[i]);
+			}
+			format->setInt32("CMCI", (uint32_t)camMemInfo);
+		}
+		else if(iCamMemMode == CAMERA_DISCONTINUOUS_MEM_VA_MODE){
+		 	//VA directly
+
+			if (mCamMemInfo == NULL) {
+				mCamMemInfo = malloc(sizeof(CamMemInfo_t));
+			}
+			CamMemInfo_t *camMemInfo = (CamMemInfo_t *)mCamMemInfo;
+			memset(camMemInfo, 0, sizeof(CamMemInfo_t));
+
+			camMemInfo->u4VdoBufCount = camMemCount;
+			camMemInfo->u4VdoBufSize = camMemSize;
+					
+			void * pTempCamMemVaArray = NULL;
+			uint32_t* pCamMemVaArray = NULL;
+			if(meta->findPointer(kKeyCamMemVaArray,&pTempCamMemVaArray) && pTempCamMemVaArray){
+				pCamMemVaArray = (uint32_t*)pTempCamMemVaArray;
+				for(int i = 0; i < camMemCount; i++){
+					camMemInfo->u4VdoBufVA[i] = pCamMemVaArray[i];
+					ALOGD("camMemInfo.u4VdoBufVA[%d]=%d", i, camMemInfo->u4VdoBufVA[i]);
+				}
+			}
+			format->setInt32("CMCI", (uint32_t)camMemInfo);
+				
+		}
+		else if(iCamMemMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE){ //ION Buffer 
+		
+			ALOGI("Camera Memory is allocated by ION");
+			if (mCamMemIonInfo == NULL) {
+				mCamMemIonInfo = malloc(sizeof(CamMemIonInfo_t));
+			}
+			CamMemIonInfo_t *camMemIonInfo = (CamMemIonInfo_t *)mCamMemIonInfo;
+			memset(camMemIonInfo, 0, sizeof(CamMemIonInfo_t));
+
+			camMemIonInfo->u4VdoBufCount = camMemCount;
+			camMemIonInfo->u4VdoBufSize = camMemSize;
+			
+			uint32_t* pCamMemIonFdArray = NULL;
+			if(meta->findPointer(kKeyCamMemIonFdArray,(void **)&pCamMemIonFdArray) && pCamMemIonFdArray){
+				for(int i = 0; i < camMemCount;i++){
+					camMemIonInfo->IonFd[i] = pCamMemIonFdArray[i];
+					ALOGD("camMemIonInfo.IonFd[%d]=%d", i, camMemIonInfo->IonFd[i]);
+				}
+			}
+
+			void * pTempCamMemVaArray = NULL;
+			uint32_t* pCamMemVaArray = NULL;
+			if(meta->findPointer(kKeyCamMemVaArray,&pTempCamMemVaArray) && pTempCamMemVaArray){
+				pCamMemVaArray = (uint32_t*)pTempCamMemVaArray;
+				for(int i = 0; i < camMemCount; i++){
+					camMemIonInfo->u4VdoBufVA[i] = pCamMemVaArray[i];
+					ALOGD("camMemIonInfo.u4VdoBufVA[%d]=%d", i, camMemIonInfo->u4VdoBufVA[i]);
+				}
+			}
+			
+			format->setInt32("CMCI", (uint32_t)camMemIonInfo);
+			
+		}
+		else{
+			ALOGW("kKeyCamMemMode is not support!");
+			return UNKNOWN_ERROR;
+		}
+				
+    }
+	//transfer coloreffect to codec
+	//codec can adjust initial Qp for special color effect such as whiteboard/blackboard
+	const char* colorEffect;
+	if(meta->findCString(kKeyColorEffect,&colorEffect)) {
+		format->setString("CoEf",colorEffect);
+	}
+#endif
+
+#ifdef MTK_HARDWARE
+    //tell codec the real width and height ap want to record
+    format->setInt32("width", mVideoWidth);
+    format->setInt32("height", mVideoHeight);
+#else
         format->setInt32("width", width);
         format->setInt32("height", height);
+#endif
         format->setInt32("stride", stride);
         format->setInt32("slice-height", sliceHeight);
         format->setInt32("color-format", colorFormat);
@@ -2004,7 +2174,11 @@ status_t StagefrightRecorder::reset() {
     // Default parameters
     mOutputFormat  = OUTPUT_FORMAT_THREE_GPP;
     mAudioEncoder  = AUDIO_ENCODER_AMR_NB;
+#ifdef MTK_HARDWARE    //In order to pass CTS test case for preview size: 320 x 240
+    mVideoEncoder  = VIDEO_ENCODER_MPEG_4_SP;
+#else
     mVideoEncoder  = VIDEO_ENCODER_DEFAULT;
+#endif
     mVideoWidth    = 176;
     mVideoHeight   = 144;
     mFrameRate     = -1;
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 527b64517..0157d3828 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -34,6 +34,10 @@
     } \
     while(0)
 
+#ifdef MTK_HARDWARE
+#include <LivePhotoSource.h>
+#include <media/stagefright/MetaData.h>
+#endif
 namespace android {
 
 class Camera;
@@ -153,6 +157,22 @@ private:
     status_t setupRawAudioRecording();
     status_t setupRTPRecording();
     status_t setupMPEG2TSRecording();
+#ifdef MTK_HARDWARE
+    String8 mRTPTarget;
+	void *mCamMemInfo;
+	void *mCamMemIonInfo;
+	void *mCamMCIMemInfo;
+	bool mSupportMCIbuffer;
+	bool mPaused;
+	String8 mArtistTag;
+	String8 mAlbumTag;
+
+	//for CTS VR parameter 1920*1080 which not 16 align
+	Size mVideoBufSizeLimit;
+	sp<LivePhotoSource> mpLivePhotoSource;
+	bool mEnableLivePhoto;
+	int32_t mLivePhotoTagValue;
+#endif
     sp<MediaSource> createAudioSource();
     status_t checkVideoEncoderCapabilities(
             bool *supportsCameraSourceMetaDataMode);
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index cdeb161f7..e021ad32e 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -111,6 +111,13 @@
 #include <stagefright/Utils.h>
 #endif
 
+#ifdef MTK_HARDWARE
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+
+#define ROUND_16(X)     ((X + 0xF) & (~0xF))
+#endif
+
 namespace android {
 
 // OMX errors are directly mapped into status_t range if
@@ -465,6 +472,14 @@ private:
 ACodec::ACodec()
     : mQuirks(0),
       mNode(0),
+#ifdef MTK_HARDWARE
+      mSupportsPartialFrames(false),
+      mLeftOverBuffer(NULL),
+      mMaxQueueBufferNum(-1),
+      mIsVideoEncoderInputSurface(0),
+      mVideoAspectRatioWidth(1),
+      mVideoAspectRatioHeight(1),
+#endif
       mSentFormat(false),
       mIsEncoder(false),
       mUseMetadataOnEncoderOutput(false),
@@ -588,6 +603,24 @@ void ACodec::signalSubmitOutputMetaDataBufferIfEOS_workaround() {
     }
 }
 
+#ifdef MTK_HARDWARE
+void ACodec::signalVEncIInterval(int seconds) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncIFrameInterval, id());
+    msg->setInt32("MtkVEncIRate", seconds);
+    msg->post();
+}
+void ACodec::signalVEncBitRate(int bitrate) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncBitRate, id());
+    msg->setInt32("MtkVEncBitRate", bitrate);
+    msg->post();
+}
+void ACodec::signalVEncFrameRate(int framerate) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncFrameRate, id());
+    msg->setInt32("MtkVEncFrameRate", framerate);
+    msg->post();
+}
+#endif
+
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     ATRACE_NAME(mComponentName.c_str());
 
@@ -1076,6 +1109,7 @@ status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     int err = mNativeWindow->cancelBuffer(
         mNativeWindow.get(), info->mGraphicBuffer.get(), -1);
 
+
     ALOGW_IF(err != 0, "[%s] can not return buffer %u to native window",
             mComponentName.c_str(), info->mBufferID);
 
@@ -1973,6 +2007,7 @@ status_t ACodec::configureCodec(
     mInputFormat = inputFormat;
     mOutputFormat = outputFormat;
 
+
     return err;
 }
 
@@ -3803,7 +3838,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("stride", videoDef->nStride);
                     notify->setInt32("slice-height", videoDef->nSliceHeight);
                     notify->setInt32("color-format", videoDef->eColorFormat);
-
                     if (mNativeWindow == NULL) {
                         DescribeColorFormatParams describeParams;
                         InitOMXParams(&describeParams);
@@ -4448,6 +4482,74 @@ status_t ACodec::requestIDRFrame() {
             sizeof(params));
 }
 
+#ifdef MTK_HARDWARE
+status_t ACodec::setVEncIInterval(int seconds) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set I frame rate");
+        OMX_INDEXTYPE index;
+        status_t err =
+        mOMX->getExtensionIndex(
+                mNode,
+                "OMX.MTK.index.param.video.EncSetIFrameRate",
+                &index);
+
+        if (err != OK) {
+            return err;
+        }
+
+        OMX_BOOL enable = OMX_TRUE;
+        err = mOMX->setConfig(mNode, index, &seconds, sizeof(seconds));
+
+        if (err != OK) {
+            ALOGE("setConfig('OMX.MTK.index.param.video.EncSetIFrameRate') returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+
+status_t ACodec::setVEncBitRate(int bitrate) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set bitrate");
+
+        OMX_BOOL enable = OMX_TRUE;
+        OMX_VIDEO_CONFIG_BITRATETYPE    bitrateType;
+        bitrateType.nEncodeBitrate = bitrate;
+        status_t err = mOMX->setConfig(mNode, OMX_IndexConfigVideoBitrate, &bitrateType, sizeof(bitrateType));
+
+        if (err != OK) {
+            ALOGE("setConfig(OMX_IndexConfigVideoBitrate) returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+status_t ACodec::setVEncFrameRate(int framerate) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set framerate");
+
+        OMX_BOOL enable = OMX_TRUE;
+        OMX_CONFIG_FRAMERATETYPE    framerateType;
+        framerateType.xEncodeFramerate = framerate<<16;
+        status_t err = mOMX->setConfig(mNode, OMX_IndexConfigVideoFramerate, &framerateType, sizeof(framerateType));
+
+        if (err != OK) {
+            ALOGE("setConfig(OMX_IndexConfigVideoFramerate) returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+#endif
 void ACodec::PortDescription::addBuffer(
         IOMX::buffer_id id, const sp<ABuffer> &buffer) {
     mBufferIDs.push_back(id);
@@ -5367,6 +5469,9 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentAllocated);
         notify->setString("componentName", mCodec->mComponentName.c_str());
+#ifdef MTK_HARDWARE
+	notify->setInt32("quirks", quirks);
+#endif
         notify->post();
     }
 
@@ -5676,6 +5781,9 @@ void ACodec::LoadedState::onCreateInputSurface(
     if (err == OK) {
         notify->setObject("input-surface",
                 new BufferProducerWrapper(bufferProducer));
+#ifdef MTK_HARDWARE
+        mCodec->mIsVideoEncoderInputSurface = 1;
+#endif
     } else {
         // Can't use mCodec->signalError() here -- MediaCodec won't forward
         // the error through because it's in the "configured" state.  We
@@ -5976,6 +6084,12 @@ bool ACodec::ExecutingState::onMessageReceived(const sp<AMessage> &msg) {
 
             mActive = false;
 
+#ifdef MTK_HARDWARE
+            if (mCodec->mLeftOverBuffer != NULL) {
+                ALOGI("clear mLeftOverBuffer %x", mCodec->mLeftOverBuffer.get());
+                mCodec->mLeftOverBuffer = NULL;
+            }
+#endif
             CHECK_EQ(mCodec->mOMX->sendCommand(
                         mCodec->mNode, OMX_CommandFlush, OMX_ALL),
                      (status_t)OK);
@@ -6003,6 +6117,29 @@ bool ACodec::ExecutingState::onMessageReceived(const sp<AMessage> &msg) {
             handled = true;
             break;
         }
+#ifdef MTK_HARDWARE
+        case kWhatMtkVEncIFrameInterval:
+        {
+            int seconds;
+            msg->findInt32("MtkVEncIRate", &seconds);
+            status_t err = mCodec->setVEncIInterval(seconds);
+            break;
+        }
+        case kWhatMtkVEncBitRate:
+        {
+            int bitrate;
+            msg->findInt32("MtkVEncBitRate", &bitrate);
+            status_t err = mCodec->setVEncBitRate(bitrate);
+            break;
+        }
+        case kWhatMtkVEncFrameRate:
+        {
+            int framerate;
+            msg->findInt32("MtkVEncFrameRate", &framerate);
+            status_t err = mCodec->setVEncFrameRate(framerate);
+            break;
+        }
+#endif
 
         case kWhatSetParameters:
         {
@@ -6147,6 +6284,7 @@ bool ACodec::ExecutingState::onOMXEvent(
 
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
 
+
                 bool isVideo = mCodec->mComponentName.find("video") != -1;
                 if (isVideo) {
                     CODEC_PLAYER_STATS(profileStart, STATS_PROFILE_RECONFIGURE);
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 613138886..824e8ac37 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -218,6 +218,34 @@ LOCAL_SHARED_LIBRARIES += \
 endif
 endif
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    ifeq ($(BOARD_MTK_OMX_USES_PRIVATE_YUV),true)
+        LOCAL_CFLAGS += -DMTK_OMX_USES_PRIVATE_YUV
+    endif
+LOCAL_MTK_PATH:=$(TOP)/mediatek/frameworks-ext/av/media/libstagefright
+    LOCAL_C_INCLUDES += \
+        $(TOP)/mediatek/kernel/include \
+        $(TOP)/mediatek/hardware/dpframework/inc \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/mediatek/frameworks/av/media/libstagefright/include \
+        $(TOP)/mediatek/frameworks-ext/av/media/libstagefright/include \
+        $(TOP)/frameworks/native/include/media/editor \
+        $(TOP)/external/skia/include/images \
+        $(TOP)/external/skia/include/core \
+
+    LOCAL_SHARED_LIBRARIES +=  \
+        libdpframework \
+        libstagefright_memutil \
+        libstagefright_enc_common \
+        libstagefright_avc_common \
+        libstagefright_foundation \
+        libdl \
+        libvcodecdrv \
+        libskia \
+        libcustom_prop
+
+endif
+
 LOCAL_SHARED_LIBRARIES += \
         libstagefright_enc_common \
         libstagefright_avc_common \
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index f8c326888..79d8b5039 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -42,6 +42,11 @@
 #define UNUSED_UNLESS_VERBOSE(x)
 #endif
 
+#ifdef MTK_HARDWARE
+#include <camera/MtkCamera.h>
+#include <camera/MtkCameraParameters.h>
+#endif
+
 namespace android {
 
 static const int64_t CAMERA_SOURCE_TIMEOUT_NS = 3000000000LL;
@@ -101,10 +106,22 @@ void CameraSourceListener::postDataTimestamp(
 }
 
 static int32_t getColorFormat(const char* colorFormat) {
+#ifdef MTK_HARDWARE
+    ALOGD("getColorFormat(%s)", colorFormat);
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
-       return OMX_COLOR_FormatYUV420Planar;
+        // YV12
+        return OMX_MTK_COLOR_FormatYV12;
     }
 
+    if (!strcmp(colorFormat, "yuv420i-yyuvyy-3plane" /*MtkCameraParameters::PIXEL_FORMAT_YUV420I)*/)) {
+        // i420
+        return OMX_COLOR_FormatYUV420Planar;
+    }
+#else
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
+       return OMX_COLOR_FormatYUV420Planar;
+    }
+#endif
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422SP)) {
        return OMX_COLOR_FormatYUV422SemiPlanar;
     }
@@ -168,11 +185,19 @@ CameraSource *CameraSource::CreateFromCamera(
     Size videoSize,
     int32_t frameRate,
     const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+	 bool storeMetaDataInVideoBuffers,bool supportMCIbuffer) {
+#else
     bool storeMetaDataInVideoBuffers) {
 
+#endif
     CameraSource *source = new CameraSource(camera, proxy, cameraId,
             clientName, clientUid, videoSize, frameRate, surface,
+#ifdef MTK_HARDWARE
+					storeMetaDataInVideoBuffers,supportMCIbuffer);
+#else
             storeMetaDataInVideoBuffers);
+#endif
     return source;
 }
 
@@ -185,7 +210,11 @@ CameraSource::CameraSource(
     Size videoSize,
     int32_t frameRate,
     const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+	bool storeMetaDataInVideoBuffers,bool supportMCIbuffer)
+#else
     bool storeMetaDataInVideoBuffers)
+#endif
     : mCameraFlags(0),
       mNumInputBuffers(0),
       mVideoFrameRate(-1),
@@ -207,6 +236,20 @@ CameraSource::CameraSource(
       mPauseEndTimeUs(0) {
     mVideoSize.width  = -1;
     mVideoSize.height = -1;
+#ifdef MTK_HARDWARE
+	mDropRate = -1;
+	mNumRemainFrameReceived = 1;
+	mLastNumFramesReceived = 1;
+	mCamVideoBufferMode = -1;
+	mCamMemVaArray = NULL;
+	mCamMemIonFdArray = NULL;
+	//for MCI buffer 
+	mSupportMCIbuffer = supportMCIbuffer;
+	mCamRecSetting = NULL;
+	//memset(&mCamRecSetting,0,sizeof(CameraRecSetting));
+	mPaused = false;
+	mResumed = true;
+#endif
 
     mInitCheck = init(camera, proxy, cameraId,
                     clientName, clientUid,
@@ -309,8 +352,13 @@ static void getSupportedVideoSizes(
  */
 status_t CameraSource::isCameraColorFormatSupported(
         const CameraParameters& params) {
+#ifdef MTK_HARDWARE
+// we need to define mtk camera color format
+	mColorFormat = OMX_MTK_COLOR_FormatYV12;
+#else
     mColorFormat = getColorFormat(params.get(
             CameraParameters::KEY_VIDEO_FRAME_FORMAT));
+#endif
     if (mColorFormat == -1) {
         return BAD_VALUE;
     }
@@ -342,10 +390,19 @@ status_t CameraSource::configureCamera(
     getSupportedVideoSizes(*params, &isSetVideoSizeSupportedByCamera, sizes);
     bool isCameraParamChanged = false;
     if (width != -1 && height != -1) {
+#ifndef MTK_HARDWARE
         if (!isVideoSizeSupported(width, height, sizes)) {
             ALOGE("Video dimension (%dx%d) is unsupported", width, height);
             return BAD_VALUE;
         }
+#endif
+#ifdef MTK_HARDWARE
+// fix wrong height size for fullHD video rec
+if (height == 1072) {
+   height = 1080;
+        ALOGD("Adjust height size (1072) for mtk camera (%dx%d)", width, height);
+}
+#endif  
         if (isSetVideoSizeSupportedByCamera) {
             params->setVideoSize(width, height);
         } else {
@@ -365,6 +422,7 @@ status_t CameraSource::configureCamera(
 
     if (frameRate != -1) {
         CHECK(frameRate > 0 && frameRate <= 120);
+#ifndef MTK_HARDWARE
         const char* supportedFrameRates =
                 params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES);
         CHECK(supportedFrameRates != NULL);
@@ -377,6 +435,7 @@ status_t CameraSource::configureCamera(
             return BAD_VALUE;
         }
 
+#endif
         // The frame rate is supported, set the camera to the requested value.
         params->setPreviewFrameRate(frameRate);
         isCameraParamChanged = true;
@@ -598,6 +657,95 @@ status_t CameraSource::initWithCameraAccess(
     ExtendedUtils::HFR::setHFRIfEnabled(params, mMeta);
     ExtendedUtils::applyPreRotation(params, mMeta);
 
+#ifdef MTK_HARDWARE
+	//get color effect and transfer to codec
+	//then codec can adjust initial Qp for special color effect such as whiteboard/blackboard
+	const char* colorEffect = newCameraParams.get(CameraParameters::KEY_EFFECT);
+	mMeta->setCString(kKeyColorEffect,colorEffect);
+	ALOGD("color effect:%s",colorEffect);
+
+	if (!mCamera->previewEnabled()) {//Camera return valid memory info after startPreview
+		ALOGW("Start preview in CameraSource");
+		mCamera->startPreview();
+	}
+
+	//for MCI buffer
+	mCamRecSetting = malloc(sizeof(CameraRecSetting));
+	CameraRecSetting* _mCamRecSetting = (CameraRecSetting*)mCamRecSetting;
+	_mCamRecSetting->mi4BufSecu = 0;
+	_mCamRecSetting->mi4BufCohe = 0;
+	if(mSupportMCIbuffer){
+		ALOGI("Support MCI buffer");
+		_mCamRecSetting->mi4BufSecu = 1;
+		_mCamRecSetting->mi4BufCohe = 1;		
+	}
+	mMeta->setInt32(kKeyCamMCIMemSecurity,_mCamRecSetting->mi4BufSecu);
+	mMeta->setInt32(kKeyCamMCIMemCoherent,_mCamRecSetting->mi4BufCohe);
+	
+	Vector<CameraRecBufInfo> VecCamBufInfo;
+	err = mCamera->sendCommand(CAMERA_CMD_GET_REC_BUF_INFO,(int32_t)&VecCamBufInfo, (int32_t)_mCamRecSetting);
+	if(err != OK){
+		//Continus memory info for 77
+		CameraMemInfo memInfo;
+		memInfo.u4Type = CameraMemInfo::eTYPE_PMEM;
+		mCamera->sendCommand(CAMERA_CMD_GET_MEM_INFO, (int32_t)&memInfo, sizeof(CameraMemInfo));
+
+		mMeta->setInt32(kKeyCamMemMode,CAMERA_CONTINUOUS_MEM_MODE);
+		mMeta->setInt32(kKeyCamMemVa, (int32_t)memInfo.u4VABase);
+		mMeta->setInt32(kKeyCamMemSize, (int32_t)memInfo.u4MemSize);
+		mMeta->setInt32(kKeyCamMemCount, (int32_t)memInfo.u4MemCount);
+		ALOGD("Camera Memory Info: VA=%d, Size=%d, Count=%d", (int32_t)memInfo.u4VABase, (int32_t)memInfo.u4MemSize, (int32_t)memInfo.u4MemCount);
+	}
+
+	else { //discontinus memory info for 89
+		if(VecCamBufInfo.size() <= 0){
+			ALOGE("get Camera Memory Info wrong!!!");
+			return err;
+		}
+
+		mMeta->setInt32(kKeyCamMemSize, (int32_t)((VecCamBufInfo.top()).u4Size));
+		mMeta->setInt32(kKeyCamMemCount, (int32_t)VecCamBufInfo.size());
+		ALOGD("Camera Memory Info: Size=%d, Count=%d", (VecCamBufInfo.top()).u4Size,VecCamBufInfo.size());
+		
+		mCamVideoBufferMode = (VecCamBufInfo.top()).i4MemId;
+		ALOGI("Camera Memory Info:Buffer mode %d",mCamVideoBufferMode);
+		
+		if(mCamVideoBufferMode > 0){
+			//Camera allocated memory by ION
+			//now will not go to here	
+				mMeta->setInt32(kKeyCamMemMode,CAMERA_DISCONTINUOUS_MEM_ION_MODE);
+			mCamMemIonFdArray = new int32_t[VecCamBufInfo.size()];
+			memset(mCamMemIonFdArray,0,sizeof(VecCamBufInfo.size() * sizeof(int32_t)));
+
+			mCamMemVaArray = new uint32_t[VecCamBufInfo.size()]; 
+			memset(mCamMemVaArray,0,sizeof(VecCamBufInfo.size() * sizeof(uint32_t)));
+			
+			for(uint32_t i = 0; i < VecCamBufInfo.size();i++){
+				//need tranfer fd for codec module
+				mCamMemIonFdArray[i] = VecCamBufInfo[i].i4MemId;
+
+				mCamMemVaArray[i] = VecCamBufInfo[i].u4VirAddr;
+				
+				ALOGI("Camera Memory Info:mCamMemIonFdArray[%d]=0x%x",i,mCamMemIonFdArray[i]);
+				ALOGI("Camera Memory Info:mCamMemVaArray[%d]=0x%x",i,mCamMemVaArray[i]);
+			}
+				
+			mMeta->setPointer(kKeyCamMemIonFdArray, mCamMemIonFdArray);
+			mMeta->setPointer(kKeyCamMemVaArray, mCamMemVaArray);
+		}
+		else{
+				mMeta->setInt32(kKeyCamMemMode,CAMERA_DISCONTINUOUS_MEM_VA_MODE);
+			mCamMemVaArray = new uint32_t[VecCamBufInfo.size()]; 
+			memset(mCamMemVaArray,0,sizeof(VecCamBufInfo.size() * sizeof(uint32_t)));
+			for(uint32_t i = 0; i < VecCamBufInfo.size();i++){
+				mCamMemVaArray[i] = VecCamBufInfo[i].u4VirAddr;
+				ALOGI("Camera Memory Info:mCamMemVaArray[%d]=0x%x",i,mCamMemVaArray[i]);
+			}
+				
+			mMeta->setPointer(kKeyCamMemVaArray, mCamMemVaArray);
+		}
+	}
+#endif
     return OK;
 }
 
@@ -610,6 +758,22 @@ CameraSource::~CameraSource() {
         // Camera's lock is released in this case.
         releaseCamera();
     }
+#ifdef MTK_HARDWARE
+	if(mCamMemVaArray){
+		delete [] mCamMemVaArray;
+		mCamMemVaArray = NULL;
+	}
+	if(mCamMemIonFdArray){
+		delete [] mCamMemIonFdArray;
+		mCamMemIonFdArray = NULL;
+	}
+
+	//for MCI buffer
+	if(mCamRecSetting){
+		free(mCamRecSetting);
+		mCamRecSetting = NULL;
+	}
+#endif
 }
 
 status_t CameraSource::startCameraRecording() {
@@ -634,6 +798,21 @@ status_t CameraSource::startCameraRecording() {
     err = OK;
     if (mCameraFlags & FLAGS_HOT_CAMERA) {
         mCamera->unlock();
+#ifdef MTK_HARDWARE //back compatible with previous app version
+		status_t err = mCameraRecordingProxy->startRecording(new ProxyListener(this));
+		ALOGD("Proxy start recording %d", err);
+		if (err == NO_INIT) {
+			mCameraFlags &= ~FLAGS_HOT_CAMERA;
+			mCamera->lock();
+			mCamera->reconnect();
+			mCameraRecordingProxy.clear();
+		}
+		else {
+			mCamera.clear();
+		}
+    }
+	if ((mCameraFlags & FLAGS_HOT_CAMERA) == 0) {
+#else
         mCamera.clear();
         if ((err = mCameraRecordingProxy->startRecording(
                 new ProxyListener(this))) != OK) {
@@ -641,6 +820,7 @@ status_t CameraSource::startCameraRecording() {
                     strerror(-err), err);
         }
     } else {
+#endif
         mCamera->setListener(new CameraSourceListener(this));
         mCamera->startRecording();
         if (!mCamera->recordingEnabled()) {
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 88217b7b9..bb6b1818e 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -1695,6 +1695,14 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             size_t max_size;
             err = mLastTrack->sampleTable->getMaxSampleSize(&max_size);
 
+#ifndef ANDROID_DEFAULT_CODE//hai.li for ISSUE: ALPS35871
+      if (max_size > 1920*1088*3/2)        // maybe some abnormal size
+	    {
+		     //mLastTrack->skipTrack = true;
+          max_size=1920*1088*3/2;
+		      ALOGE("ERROR: Sample size may be wrong!set maxSize as:%d",max_size);
+	    }
+#endif
             if (err != OK) {
                 return err;
             }
diff --git a/media/libstagefright/MediaBuffer.cpp b/media/libstagefright/MediaBuffer.cpp
index 1f80a47de..2d4f23284 100644
--- a/media/libstagefright/MediaBuffer.cpp
+++ b/media/libstagefright/MediaBuffer.cpp
@@ -83,6 +83,20 @@ MediaBuffer::MediaBuffer(const sp<ABuffer> &buffer)
       mMetaData(new MetaData),
       mOriginal(NULL) {
 }
+#ifdef MTK_HARDWARE
+MediaBuffer::MediaBuffer(size_t size, sp<MetaData> metaData)
+	: mObserver(NULL),
+	  mNextBuffer(NULL),
+	  mRefCount(0),
+	  mData(malloc(size)),
+	  mSize(size),
+	  mRangeOffset(0),
+	  mRangeLength(size),
+	  mOwnsData(true),
+	  mMetaData(new MetaData(*(metaData.get()))),
+	  mOriginal(NULL) {
+}
+#endif
 
 void MediaBuffer::release() {
     if (mObserver == NULL) {
@@ -199,4 +213,12 @@ MediaBuffer *MediaBuffer::clone() {
     return buffer;
 }
 
+#ifdef MTK_HARDWARE
+// just do a release on refcount == 0
+void MediaBufferSimpleObserver::signalBufferReturned(MediaBuffer *buffer) {
+    CHECK_EQ(buffer->refcount(), 0);
+    buffer->setObserver(NULL);
+    buffer->release();
+}
+#endif
 }  // namespace android
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index 7c81570ad..0ca4c7a1d 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -454,6 +454,12 @@ status_t MediaCodecSource::initEncoder() {
                 mCodecLooper, outputMIME.c_str(), true /* encoder */);
     }
 
+	// remove camera tag from mime
+    if (outputMIME.endsWith("_cam")) {
+        outputMIME.erase(outputMIME.size() - 4, 4);
+        mOutputFormat->setString("mime", outputMIME);
+    }
+
     if (mEncoder == NULL) {
         return NO_INIT;
     }
diff --git a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
index 629bd129c..2edb550cc 100644
--- a/media/libstagefright/OMXClient.cpp
+++ b/media/libstagefright/OMXClient.cpp
@@ -92,6 +92,25 @@ struct MuxOMX : public IOMX {
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer, OMX_BOOL crossProcess);
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer);
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer);
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap);
+
+    virtual status_t registerBuffer2(
+        node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase);
+
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer);
+#endif
     virtual status_t useGraphicBuffer(
             node_id node, OMX_U32 port_index,
             const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer);
@@ -319,6 +338,34 @@ status_t MuxOMX::useBuffer(
             node, port_index, params, buffer, OMX_FALSE /* crossProcess */);
 }
 
+#ifdef MTK_HARDWARE
+status_t MuxOMX::useBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+        buffer_id *buffer) {
+    return getOMX(node)->useBuffer(node, port_index, virAddr, size, buffer);
+}
+
+status_t MuxOMX::useBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+        buffer_id *buffer) {
+    return getOMX(node)->useBuffer(node, port_index, virAddr, size, offset, buffer);
+}
+
+status_t MuxOMX::registerBuffer(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+    return getOMX(node)->registerBuffer(node, port_index, heap);
+}
+
+status_t MuxOMX::registerBuffer2(
+        node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase) {
+    return getOMX(node)->registerBuffer2(node, port_index, HeapBase);
+}
+
+status_t MuxOMX::useIonBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+    return getOMX(node)->useIonBuffer(node, port_index, virAddr, fd, size, buffer);
+}
+#endif
 status_t MuxOMX::useGraphicBuffer(
         node_id node, OMX_U32 port_index,
         const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer) {
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 4a5375515..c045b5ef7 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -124,6 +124,13 @@
 #include "ExynosHWCService.h"
 #endif
 
+#ifdef MTK_HARDWARE
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+#include "sf_mem_util.h"
+#include <cutils/properties.h>
+#endif
+
 namespace android {
 
 #ifdef USE_SAMSUNG_COLORFORMAT
@@ -328,6 +335,17 @@ void OMXCodec::findMatchingCodecs(
         return;
     }
 
+	AString *tempMime = new AString(mime);
+    if (tempMime->endsWith("_cam")) {
+        // remove camera tag from mime
+        tempMime->erase(tempMime->size() - 4, 4);
+        mime = tempMime->c_str();
+    }
+    else {
+        // no camera recording, prefer software codecs
+        flags |= kPreferSoftwareCodecs;
+    }
+
     size_t index = 0;
 
 #ifdef ENABLE_AV_ENHANCEMENTS
@@ -428,6 +446,13 @@ uint32_t OMXCodec::getComponentQuirks(
     if (info->hasQuirk("requires-flush-complete-emulation")) {
         quirks |= kRequiresFlushCompleteEmulation;
     }
+
+#ifdef MTK_HARDWARE
+    if (info->hasQuirk("avoid-memcpy-input-recording-frames")) {
+        quirks |= kAvoidMemcopyInputRecordingFrames;
+    }
+#endif
+
 #endif // DOLBY_END
 
 #ifdef USE_ALP_AUDIO
@@ -599,6 +624,52 @@ sp<MediaSource> OMXCodec::Create(
                     createEncoder, mime, componentName,
                     source, nativeWindow);
 
+#ifdef MTK_HARDWARE  // Camera recording
+            int32_t prCamMode;
+            int32_t prCamMemInfo;   //CamMemInfo_t pointer
+            CamMCIMemInfo_t* camMCIMemInfo = NULL;
+
+            if (meta->findInt32(kKeyCamMemMode, &prCamMode)) {
+                ALOGD ("Camera Recording Mode (%d)", prCamMode);
+            }
+
+            if (meta->findPointer(kKeyCamMCIMemInfo, (void **)&camMCIMemInfo)) {
+                ALOGD ("Camera Recording SetMCIMode (security = %d, coherent = %d)", camMCIMemInfo->u4Security, camMCIMemInfo->u4Coherent);
+                codec->getCameraMeta()->setPointer(kKeyCamMCIMemInfo, camMCIMemInfo);
+            }
+
+            if (prCamMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE) {
+            	if (meta->findInt32(kKeyCamMemInfo, &prCamMemInfo)) {
+                    ALOGD ("Hello camera recording MEM ION MODE!!!");
+                    for(uint32_t u4I = 0; u4I < ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+                    {
+                        ALOGD ("VdoBufVA = 0x%08x, IonFd = %d, VdoBufCount = %d, VdoBufSize = %d,\n",
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->IonFd,
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufSize
+                                       );
+                    }
+                    codec->getCameraMeta()->setInt32(kKeyCamMemMode, prCamMode);
+                    codec->getCameraMeta()->setInt32(kKeyCamMemInfo, prCamMemInfo);
+            	}
+            }
+            else {   // CAMERA_DISCONTINUOUS_MEM_VA_MODE
+            if (meta->findInt32(kKeyCamMemInfo, &prCamMemInfo)) {
+                    ALOGD ("Hello camera recording MEM VA MODE!!!");
+                for(uint32_t u4I = 0; u4I < ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+                {
+                    ALOGD ("VdoBufVA = 0x%08x, VdoBufCount = %d, VdoBufSize = %d,\n",
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufSize
+                        );
+                }
+                    codec->getCameraMeta()->setInt32(kKeyCamMemMode, prCamMode);
+                codec->getCameraMeta()->setInt32(kKeyCamMemInfo, prCamMemInfo);
+            }
+            }
+#endif
             observer->setCodec(codec);
 
             { //profile configure codec
@@ -1844,6 +1915,13 @@ OMXCodec::OMXCodec(
       mDolbyProcessedAudio(false),
       mDolbyProcessedAudioStateChanged(false),
 #endif // DOLBY_END
+#ifdef MTK_HARDWARE
+      mInputBufferPoolMemBase(NULL),
+      mOutputBufferPoolMemBase(NULL),
+      mMemHeapBase(NULL),
+      mSupportsPartialFrames(false),
+      mIsVENCTimelapseMode(false),
+#endif
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11)
               || !strncmp(componentName, "OMX.ffmpeg.", 11))
@@ -1855,6 +1933,16 @@ OMXCodec::OMXCodec(
     mPortStatus[kPortIndexOutput] = ENABLING;
 
     setComponentRole();
+
+
+#ifdef MTK_HARDWARE  // for Camera recording
+            mCameraMeta = new MetaData;
+
+            if (!mOMXLivesLocally) {
+                mQuirks &= ~kAvoidMemcopyInputRecordingFrames;
+            }
+#endif
+
 }
 
 // static
@@ -2000,6 +2088,30 @@ OMXCodec::~OMXCodec() {
 
     free(mMIME);
     mMIME = NULL;
+
+#ifdef MTK_HARDWARE
+
+    if (mMemHeapBase != NULL)
+    {
+        if (mInputBufferPoolMemBase) {
+            if (mOMXLivesLocally) {
+                sf_memheap_remove_info (mInputBufferPoolMemBase);
+            }
+            mInputBufferPoolMemBase = NULL;
+        }
+
+        if (mOutputBufferPoolMemBase) {
+            if (mOMXLivesLocally) {
+                sf_memheap_remove_info (mOutputBufferPoolMemBase);
+            }
+            mOutputBufferPoolMemBase = NULL;
+        }
+        mMemHeapBase = NULL;
+    }
+
+//    ALOGD ("!@@!>> destroy tid (%d) OMXCodec mOMXLivesLocally=%d, mIsVideoDecoder(%d), mIsVideoEncoder(%d)", gettid(), mOMXLivesLocally, mIsVideoDecoder, mIsVideoEncoder);
+#endif
+
 }
 
 status_t OMXCodec::init() {
@@ -2787,6 +2899,16 @@ void OMXCodec::on_message(const omx_message &msg) {
 
             // Buffer could not be released until empty buffer done is called.
             if (info->mMediaBuffer != NULL) {
+
+#ifdef MTK_HARDWARE
+                if (mIsEncoder &&
+                    (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+                    // If zero-copy mode is enabled this will send the
+                    // input buffer back to the upstream source.
+                    restorePatchedDataPointer(info);
+                }
+#endif
+
                 info->mMediaBuffer->release();
                 info->mMediaBuffer = NULL;
             }
@@ -3849,6 +3971,8 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         }
 
         bool releaseBuffer = true;
+
+
         if (mFlags & kStoreMetaDataInVideoBuffers) {
                 releaseBuffer = false;
                 info->mMediaBuffer = srcBuffer;
@@ -3985,6 +4109,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 	interlaceFrameCount++;
     }
 
+
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
     } else if (ExtendedUtils::checkIsThumbNailMode(mFlags, mComponentName)
@@ -4676,6 +4801,63 @@ sp<MetaData> OMXCodec::getFormat() {
     return mOutputFormat;
 }
 
+#ifdef MTK_HARDWARE  // for Camera recording
+sp<MetaData> OMXCodec::getCameraMeta() {
+    Mutex::Autolock autoLock(mLock);
+
+    return mCameraMeta;
+}
+
+status_t OMXCodec::vEncSetForceIframe(bool enable) {
+    if (mIsVideoEncoder) {
+        if (!strncmp(mComponentName, "OMX.MTK.", 8)) {
+            OMX_INDEXTYPE index;
+            status_t err =
+            mOMX->getExtensionIndex(
+                    mNode,
+                    "OMX.MTK.index.param.video.EncSetForceIframe",
+                    &index);
+
+            if (err != OK) {
+                return err;
+            }
+
+            OMX_BOOL enable = OMX_TRUE;
+            err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));
+
+            if (err != OK) {
+                CODEC_LOGE("setConfig('OMX.MTK.index.param.video.EncSetForceIframe') returned error 0x%08x", err);
+                return err;
+            }
+        }
+    }
+
+    return OK;
+}
+
+#ifdef MTK_HARDWARE
+// for dynamic bit-rate adjustment [
+status_t OMXCodec::vEncSetBitRate(unsigned int u4BitRate) {
+
+    OMX_VIDEO_CONFIG_BITRATETYPE ConfigBitrate;
+    status_t err;
+
+    if (mIsVideoEncoder) {
+        //CODEC_LOGE("@@@>> set bit rate >> %d",u4BitRate);
+        ConfigBitrate.nEncodeBitrate = u4BitRate;
+        ConfigBitrate.nPortIndex = kPortIndexOutput;
+        err = mOMX->setConfig(mNode, OMX_IndexConfigVideoBitrate, &ConfigBitrate, sizeof(OMX_VIDEO_CONFIG_BITRATETYPE));
+        if (err != OK) {
+            CODEC_LOGE("Fail to adjust bit-rate, returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+// ]
+#endif //MTK_HARDWARE
+#endif
+
 status_t OMXCodec::read(
         MediaBuffer **buffer, const ReadOptions *options) {
     ATRACE_CALL();
@@ -4717,6 +4899,36 @@ status_t OMXCodec::read(
             mPaused = false;
         }
 
+#ifdef MTK_HARDWARE  // Morris Yang for Camera recording
+        if (mCameraMeta.get() != NULL) {
+            int32_t _initial_submit_count = 0;
+            int32_t _initial_submit_limit = 2;
+            if (mIsVENCTimelapseMode) {
+            	_initial_submit_limit = 1;
+            	ALOGD ("Submit one frame for timelapse mode!!");
+            }
+            Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
+            for (size_t i = 0; i < buffers->size(); ++i) {
+                BufferInfo *info = &buffers->editItemAt(i);
+
+                if (info->mStatus != OWNED_BY_US) {
+                    continue;
+                }
+
+                if (!drainInputBuffer(info)) {
+                    break;
+                }
+
+                _initial_submit_count++;
+                if (_initial_submit_count == _initial_submit_limit) {
+                    break;
+                }
+            }
+        }
+        else {
+            drainInputBuffers();
+        }
+#endif
 
         if (mState == EXECUTING) {
             // Otherwise mState == RECONFIGURING and this code will trigger
@@ -5231,7 +5443,11 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                     CHECK(!"Unknown compression format.");
                 }
             }
-
+#ifdef MTK_HARDWARE
+if (video_def->nFrameHeight == 1072) {
+   video_def->nFrameHeight = 1080;
+}
+#endif   
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
@@ -5369,6 +5585,15 @@ status_t OMXCodec::resumeLocked(bool drainInputBuf) {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+#ifdef MTK_HARDWARE
+void OMXCodec::restorePatchedDataPointer(BufferInfo *info) {
+    CHECK(mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames));
+    CHECK(mOMXLivesLocally);
+
+    OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+    header->pBuffer = (OMX_U8 *)info->mData;
+}
+#endif
 
 status_t QueryCodecs(
         const sp<IOMX> &omx,
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 37b21a25c..937034b7f 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -38,6 +38,22 @@
 #include <gralloc_priv.h>
 #endif
 
+#ifdef MTK_HARDWARE
+#include <cutils/properties.h>
+#include <SkImageEncoder.h>
+#include <SkBitmap.h>
+#include <cutils/xlog.h>
+#undef ALOGE
+#undef ALOGW
+#undef ALOGI
+#undef ALOGD
+#undef ALOGV
+#define ALOGE XLOGE
+#define ALOGW XLOGW
+#define ALOGI XLOGI
+#define ALOGD XLOGD
+#define ALOGV XLOGD
+#endif
 namespace android {
 
 SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeight) :
@@ -55,6 +71,12 @@ SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeig
     mUseAbsoluteTimestamps(false) {
     ALOGV("SurfaceMediaSource");
 
+#ifdef MTK_HARDWARE
+    mBackupBufsIndex = 0;
+    mBackupBufsMax = 0;
+    
+    mIsBinderDied = false;
+#endif
     if (bufferWidth == 0 || bufferHeight == 0) {
         ALOGE("Invalid dimensions %dx%d", bufferWidth, bufferHeight);
     }
@@ -284,6 +306,10 @@ static void passMetadataBuffer(MediaBuffer **buffer,
 
 status_t SurfaceMediaSource::read(
         MediaBuffer **buffer, const ReadOptions * /* options */) {
+#ifdef MTK_HARDWARE
+    sp<Fence> bufferFence = NULL;
+    {
+#endif 
     ALOGV("read");
     Mutex::Autolock lock(mMutex);
 
@@ -307,6 +333,9 @@ status_t SurfaceMediaSource::read(
             // wait for a buffer to be queued
             mFrameAvailableCondition.wait(mMutex);
         } else if (err == OK) {
+#ifdef MTK_HARDWARE
+            bufferFence = item.mFence;			
+#endif
             err = item.mFence->waitForever("SurfaceMediaSource::read");
             if (err) {
                 ALOGW("read: failed to wait for buffer fence: %d", err);
@@ -382,7 +411,19 @@ status_t SurfaceMediaSource::read(
     mPendingBuffers.push_back(*buffer);
 #endif
 
+#ifndef MTK_HARDWARE
     ALOGV("returning mbuf %p", *buffer);
+#endif
+
+#ifdef MTK_HARDWARE
+    }
+
+    if (bufferFence != NULL) {
+        bufferFence->waitForever("SMS aquire buffer");
+    }
+
+    dumpBuffer();
+#endif
 
     return OK;
 }
@@ -485,6 +526,387 @@ void SurfaceMediaSource::onBuffersReleased() {
        mSlots[i].mGraphicBuffer = 0;
     }
 }
+#ifdef MTK_HARDWARE
+status_t SurfaceMediaSource::binderDied()
+{
+    if (!mStarted) {
+        return OK;
+    }
+
+    XLOGW("[SMS] binder is dead, broadcast");
+    mIsBinderDied = true;    
+    mFrameAvailableCondition.broadcast();
+
+    return OK;
+}
+
+void SurfaceMediaSource::drainBufferQueue()
+{
+    status_t err = OK;
+    BufferQueue::BufferItem item;
+    
+    while (err == OK) {
+
+    }
+}
+
+static uint32_t single_count = 0;
+
+void SurfaceMediaSource::dumpBuffer(){
+    char     value[PROPERTY_VALUE_MAX];
+    property_get("debug.sms.layerdump", value, "0");
+
+    int param = atoi(value);
+
+    if (param == 1)
+        single_count ++;
+    else
+        single_count = 0;
+
+    switch (param)
+    {
+    case -1:
+        system("mkdir /data/SMS_dump");
+        activeBufferBackup();
+        break;
+
+    case 0:
+        dumpContinuousBuffer();
+        break;
+
+    case 1:
+        system("mkdir /data/SMS_dump");
+        dumpSingleBuffer();
+        break;
+
+    default:
+        return;
+    }
+}
+
+void SurfaceMediaSource::dumpSingleBuffer()
+{
+    sp<GraphicBuffer> graphicBuffer = mSlots[mCurrentSlot].mGraphicBuffer;
+    if (graphicBuffer != NULL) {
+        bool     raw = false;
+        uint32_t identity;
+
+        char             fname[128];
+        void*            ptr;
+        float            bpp;
+        SkBitmap         b;
+        SkBitmap::Config c;
+
+        bpp = 1.0f;
+        c = SkBitmap::kNo_Config;
+        switch (graphicBuffer->format) {
+            case PIXEL_FORMAT_RGBA_8888:
+            case PIXEL_FORMAT_RGBX_8888:
+                if (false == raw) {
+                    c = SkBitmap::kARGB_8888_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.png", identity);
+                } else {
+                    bpp = 4.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.RGBA", identity);
+                }
+                break;
+            case PIXEL_FORMAT_BGRA_8888:
+            case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+                if (false == raw) {
+                    c = SkBitmap::kARGB_8888_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d(RBswapped).png", identity);
+                } else {
+                    bpp = 4.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.BGRA", identity);
+                }
+                break;
+            case PIXEL_FORMAT_RGB_565:
+                if (false == raw) {
+                    c = SkBitmap::kRGB_565_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.png", identity);
+                } else {
+                    bpp = 2.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.RGB565", identity);
+                }
+                break;
+            case HAL_PIXEL_FORMAT_I420:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.i420", identity);
+                break;
+            case HAL_PIXEL_FORMAT_NV12_BLK:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.nv12_blk", identity);
+                break;
+            case HAL_PIXEL_FORMAT_NV12_BLK_FCM:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.nv12_blk_fcm", identity);
+                break;
+            case HAL_PIXEL_FORMAT_YV12:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.yv12", identity);
+                break;
+            default:
+                XLOGE("[%s] cannot dump format:%d for identity:%d",
+                      __func__, graphicBuffer->format, identity);
+                return;
+        }
+
+        {
+            //Mutex::Autolock _l(mDumpLock);
+            graphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &ptr);
+            {
+                XLOGI("    %s (config:%d, stride:%d, height:%d, ptr:%p)",
+                    fname, c, graphicBuffer->stride, graphicBuffer->height, ptr);
+
+                if (SkBitmap::kNo_Config != c) {
+                    b.setConfig(c, graphicBuffer->stride, graphicBuffer->height);
+                    b.setPixels(ptr);
+                    SkImageEncoder::EncodeFile(fname, b, SkImageEncoder::kPNG_Type,
+                                               SkImageEncoder::kDefaultQuality);
+                } else {
+                    uint32_t size = graphicBuffer->stride * graphicBuffer->height * bpp;
+                    FILE *f = fopen(fname, "wb");
+                    if (f != NULL)
+                    {
+                        fwrite(ptr, size, 1, f);
+                        fclose(f);
+                    }
+                    else
+                        XLOGW("file %s open fail", fname);
+                }
+            }
+            graphicBuffer->unlock();
+        }
+    }
+}
+
+void SurfaceMediaSource::activeBufferBackup() {
+
+    sp<GraphicBuffer> graphicBuffer = mSlots[mCurrentSlot].mGraphicBuffer;
+    
+    if (graphicBuffer == NULL) {
+        XLOGW("[SMS::activeBufferBackup] graphicBuffer=%p not initialized", graphicBuffer.get());
+        return;
+    }
+    
+    if (true) {
+        XLOGV("[SMS::activeBufferBackup] +");
+        // check bpp
+        float bpp = 0.0f;
+        uint32_t width  = graphicBuffer->width;
+        uint32_t height = graphicBuffer->height;
+        uint32_t format = graphicBuffer->format;
+        uint32_t usage  = graphicBuffer->usage;
+        uint32_t stride = graphicBuffer->stride;
+        status_t err;
+        
+        switch (graphicBuffer->format) {
+            case PIXEL_FORMAT_RGBA_8888:
+            case PIXEL_FORMAT_BGRA_8888:
+            case PIXEL_FORMAT_RGBX_8888:
+            case 0x1ff:
+                // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+                bpp = 4.0;
+                break;
+            case PIXEL_FORMAT_RGB_565:
+                bpp = 2.0;
+                break;
+            case HAL_PIXEL_FORMAT_I420:
+                bpp = 1.5;
+                break;
+            case HAL_PIXEL_FORMAT_YV12:
+                bpp = 1.5;
+                break;
+            default:
+                XLOGE("[%s] SMS cannot dump format:%d for identity", __func__, graphicBuffer->format);
+                break;
+        }
+
+#define MAX_DEFAULT_BUFFERS 10
+        // initialize backup buffer max size
+        char value[PROPERTY_VALUE_MAX];
+
+        property_get("debug.sf.contbufsmax", value, "0");
+        uint32_t max = atoi(value);
+        if (max <= 0)
+            max = MAX_DEFAULT_BUFFERS;
+
+        if (mBackupBufsMax != max) {
+            mBackupBufsMax = max;
+            XLOGI("==>  ring buffer max size, max = %d", max);
+
+            mBackBufs.clear();
+            mBackupBufsIndex = 0;
+        }
+
+        // create new GraphicBuffer
+        if (mBackBufs.size() < mBackupBufsMax) {
+            sp<GraphicBuffer> buf;
+            buf = new GraphicBuffer(width, height, format, usage);
+            mBackBufs.push(buf);
+
+            XLOGI("[SMS] new buffer for cont. dump, size = %d", mBackBufs.size());
+        }
+
+        // detect geometry changed
+        if (mBackBufs[mBackupBufsIndex]->width != graphicBuffer->width || 
+            mBackBufs[mBackupBufsIndex]->height != graphicBuffer->height ||
+            mBackBufs[mBackupBufsIndex]->format != graphicBuffer->format) {
+            XLOGI("[SMS] geometry changed, backup=(%d, %d, %d) ==> active=(%d, %d, %d)",
+                mBackBufs[mBackupBufsIndex]->width,
+                mBackBufs[mBackupBufsIndex]->height,
+                mBackBufs[mBackupBufsIndex]->format,
+                graphicBuffer->width,
+                graphicBuffer->height,
+                graphicBuffer->format);
+
+            sp<GraphicBuffer> buf;
+            buf = new GraphicBuffer(width, height, format, usage);
+            mBackBufs.replaceAt(buf, mBackupBufsIndex);
+        }
+
+        if (graphicBuffer.get() == NULL || mBackBufs[mBackupBufsIndex] == NULL) {
+            XLOGW("[SMS::activeBufferBackup] backup fail, graphicBuffer=%p, mBackBufs[%d]=%p",
+                graphicBuffer.get(), mBackupBufsIndex, mBackBufs[mBackupBufsIndex].get());
+            return;
+        }
+        
+        // backup
+        nsecs_t now = systemTime();        
+
+        void* src;
+        void* dst;
+        err = graphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &src);
+        if (err != NO_ERROR) {
+            XLOGW("[SMS::activeBufferBackup] lock active buffer failed");
+            return;
+        }
+
+        XLOGV("[SMS::activeBufferBackup] lock +, req=%d");
+        err = mBackBufs[mBackupBufsIndex]->lock(GraphicBuffer::USAGE_SW_READ_OFTEN | GraphicBuffer::USAGE_SW_WRITE_OFTEN, &dst);
+        if (err != NO_ERROR) {
+            XLOGW("[SMS::activeBufferBackup] lock backup buffer failed");
+            return;
+        }
+
+        backupProcess(dst, src, stride*height*bpp);
+
+        mBackBufs[mBackupBufsIndex]->unlock();
+        graphicBuffer->unlock();
+
+        XLOGI("[SMS::activeBufferBackup] buf=%d, time=%lld", mBackupBufsIndex, ns2ms(systemTime() - now));
+
+        mBackupBufsIndex ++;
+        if (mBackupBufsIndex >= mBackupBufsMax)
+            mBackupBufsIndex = 0;
+    }
+}
+
+void SurfaceMediaSource::backupProcess(void* dst, void* src, size_t size) {
+    XLOGV("[SMS::backupProcess] +");
+
+    // backup 
+    memcpy(dst, src, size);
+
+    XLOGV("[SMS::backupProcess] -");
+}
+
+void SurfaceMediaSource::dumpContinuousBuffer() {
+    char tmp[PROPERTY_VALUE_MAX];
+
+    if (0 == mBackBufs.size())
+        return;
+
+    if (mBackupBufsMax <= 0) {
+        XLOGW("[SMS::dumpContinuousBuffer] mBackupBufsMax not updated");
+        return;
+    }
+
+    XLOGD("[SMS::dumpContinuousBuffer] +, size=%d", mBackBufs.size());
+
+    if (true) {
+        int start = (mBackupBufsIndex + mBackupBufsMax - 1) % mBackupBufsMax;
+        int size = mBackBufs.size();
+        for (uint32_t i = 0; i < mBackupBufsMax; i++) {
+            if (i >= mBackBufs.size()) {
+                XLOGW("[SMS::dumpContinuousBuffer] overflow i=%d, max=%d", i, mBackBufs.size());
+                break;
+            }
+
+            int index = (start + mBackupBufsMax - i) % mBackupBufsMax;
+            XLOGD("[SMS::dumpContinuousBuffer] i=%d, index=%d", mBackupBufsMax - i, index);
+            sp<GraphicBuffer> buf = mBackBufs[index];
+            dumpGraphicBuffer(buf, size - i);
+        }
+    }
+
+    mBackBufs.clear();
+    property_set("debug.sms.layerdump", "0");
+
+    XLOGD("[SMS::dumpContinuousBuffer] -, size=%d", mBackBufs.size());
+}
+
+void SurfaceMediaSource::dumpGraphicBuffer(sp<GraphicBuffer> buf, int index) {
+    char             fname[128];
+    void*            ptr;
+    SkBitmap         b;
+    SkBitmap::Config c;
+    float            bpp;
+    
+    
+    c = SkBitmap::kNo_Config;
+    switch (buf->format) {
+        case PIXEL_FORMAT_RGBA_8888:
+        case PIXEL_FORMAT_BGRA_8888:
+        case PIXEL_FORMAT_RGBX_8888:
+        case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+            c = SkBitmap::kARGB_8888_Config;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.png", index);
+            break;
+        case PIXEL_FORMAT_RGB_565:
+            c = SkBitmap::kRGB_565_Config;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.png", index);
+            break;
+        case HAL_PIXEL_FORMAT_I420:
+            bpp = 1.5;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.i420", index);
+            break;
+        case HAL_PIXEL_FORMAT_YV12:
+            bpp = 1.5;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.yv12", index);
+            break;
+        default:
+            XLOGE("[%s] SMS cannot dump format:%d", __func__, buf->format);
+            return;
+    }
+
+    buf->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &ptr);
+    {
+        XLOGI("[SMS::dumpGraphicBuffer]");
+        XLOGI("    %s (config:%d, stride:%d, height:%d, ptr:%p)",
+            fname, c, buf->stride, buf->height, ptr);
+
+        if (SkBitmap::kNo_Config != c) {
+            b.setConfig(c, buf->stride, buf->height);
+            b.setPixels(ptr);
+            SkImageEncoder::EncodeFile(
+                fname, b, SkImageEncoder::kPNG_Type, SkImageEncoder::kDefaultQuality);
+        } else {
+            uint32_t size = buf->stride * buf->height * bpp;
+            FILE *f = fopen(fname, "wb");
+            if (f != NULL)
+            {
+                fwrite(ptr, size, 1, f);
+                fclose(f);
+            }
+            else
+                XLOGW("file %s open fail", fname);
+        }
+    }
+    buf->unlock();
+}
+
+#endif
 
 void SurfaceMediaSource::onSidebandStreamChanged() {
     ALOG_ASSERT(false, "SurfaceMediaSource can't consume sideband streams");
diff --git a/media/libstagefright/codecs/aacenc/Android.mk b/media/libstagefright/codecs/aacenc/Android.mk
index 58ec3ba6a..c6396d24b 100644
--- a/media/libstagefright/codecs/aacenc/Android.mk
+++ b/media/libstagefright/codecs/aacenc/Android.mk
@@ -82,7 +82,7 @@ LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV7
 endif
 
-LOCAL_CFLAGS += -Werror
+#LOCAL_CFLAGS += -Werror
 
 include $(BUILD_STATIC_LIBRARY)
 
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 59a64ba25..a8a1cf0cc 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -9,6 +9,12 @@ LOCAL_C_INCLUDES := \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/hardware/msm7k
 
+
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+        $(TOP)/mediatek/hardware/dpframework/inc 
+endif
+
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f91..d8cd035b0 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,6 +22,20 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
+#ifdef MTK_HARDWARE
+#include "OMX_IVCommon.h"
+#include <ctype.h>
+#include <cutils/properties.h>
+
+#define MEM_ALIGN_32              32
+#define BITBLT_TRYALLOCMEMCOUNT   200
+#include "DpBlitStream.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <cutils/properties.h>
+#include <utils/Timers.h>
+#endif
+
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -37,10 +51,15 @@ ColorConverter::~ColorConverter() {
 }
 
 bool ColorConverter::isValid() const {
+#ifdef MTK_HARDWARE
+	ALOGD ("MTK: isValid: src format: 0x%x, Dst format: 0x%x", 
+		mSrcFormat, mDstFormat);
+    if ((mDstFormat != OMX_COLOR_Format16bitRGB565) && (mDstFormat != OMX_COLOR_Format32bitARGB8888)) {
+#else
     if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
+#endif
         return false;
     }
-
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
@@ -85,9 +104,15 @@ status_t ColorConverter::convert(
         size_t dstWidth, size_t dstHeight,
         size_t dstCropLeft, size_t dstCropTop,
         size_t dstCropRight, size_t dstCropBottom) {
+#ifndef MTK_HARDWARE
+    if ((mDstFormat != OMX_COLOR_Format16bitRGB565) && (mDstFormat != OMX_COLOR_Format32bitARGB8888)) {
+		return ERROR_UNSUPPORTED;
+    }
+#else
     if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
         return ERROR_UNSUPPORTED;
     }
+#endif
 
     BitmapParams src(
             const_cast<void *>(srcBits),
@@ -103,7 +128,11 @@ status_t ColorConverter::convert(
 
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
+#ifndef MTK_HARDWARE
+            err = convertYUVToRGBHW(src, dst);
+#else
             err = convertYUV420Planar(src, dst);
+#endif
             break;
 
         case OMX_COLOR_FormatCbYCrY:
@@ -122,6 +151,14 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+#ifdef MTK_HARDWARE
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
+        case OMX_COLOR_FormatVendorMTKYUV_FCM:
+            err = convertYUVToRGBHW(src, dst);
+            break;
+#endif
+
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -521,4 +558,226 @@ uint8_t *ColorConverter::initClip() {
     return &mClip[-kClipMin];
 }
 
+#ifdef MTK_HARDWARE
+// convert MTKYUV to RGB565 (SW)
+bool ColorConverter::SWYUVToRGBConversion(const BitmapParams &src, const BitmapParams &dst)
+{
+    status_t err;
+
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+        err = convertYUV420Planar(src, dst);
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+        err = convertYUV420PlanarToABGR8888(src, dst);
+    }
+    else {
+        ALOGE ("[ERROR] Unsupported dst format (0x%08X) in SWYUVToRGBConversion");
+        err = ERROR_UNSUPPORTED;
+    }
+
+    if (err == OK) {
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+status_t ColorConverter::convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst)
+{
+	ALOGD("srcWidth(%d), srcHeight(%d), srcCropLeft(%d), srcCropTop(%d), srcCropRight(%d), srcCropBottom(%d)",
+       src.mWidth, src.mHeight, src.mCropLeft, src.mCropTop, src.mCropRight, src.mCropBottom);
+    ALOGD("dstWidth(%d), dstHeight(%d), dstCropLeft(%d), dstCropTop(%d), dstCropRight(%d), dstCropBottom(%d)",
+       dst.mWidth, dst.mHeight, dst.mCropLeft, dst.mCropTop, dst.mCropRight, dst.mCropBottom);
+    DpBlitStream blitStream;
+
+//    int srcWidth = src.cropWidth();
+//    int srcHeight = src.cropHeight();
+// reverse-engineered color conversion from JB libstagefright.so for mt6589 by blackrebel
+
+       int srcHStride = src.mHeight; 
+       int srcWStride = src.mWidth;
+       
+    if (mSrcFormat != OMX_COLOR_FormatYUV420Planar) {
+       srcWStride = (src.mWidth + 15) & 0xFFFFFFF0;
+       srcHStride = (src.mHeight + 31) & 0xFFFFFFE0;
+    }
+	
+    DpRect srcRoi;
+    srcRoi.x = 0;
+    srcRoi.y = 0;
+    srcRoi.w = dst.mWidth;
+    srcRoi.h = dst.mHeight;
+
+    ALOGD("convertYUVToRGBHW: src stride aligned, w(%d), h(%d)", srcWStride, srcHStride);
+
+    unsigned int dstWStride = dst.mWidth ;
+    unsigned int dstHStride = dst.mHeight ;
+
+    if (mSrcFormat == OMX_COLOR_FormatYUV420Planar) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+	      length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+	ALOGD("OMX_COLOR_FormatYUV420Planar: Yaddr(%p), Uaddr(%p), Vaddr(%p) YUV420P", planar[0], planar[1], planar[2]);
+	ALOGD("OMX_COLOR_FormatYUV420Planar: Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eYUV_420_3P);
+    }
+/*
+	if (mSrcFormat == OMX_MTK_COLOR_FormatYV12) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+	ALOGD("OMX_MTK_COLOR_FormatYV12: Yaddr(%p), Uaddr(%p), Vaddr(%p) YV12", planar[0], planar[1], planar[2]);
+	ALOGD("OMX_MTK_COLOR_FormatYV12: Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eYV12);
+    }
+*/
+    if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+	ALOGD("OMX_COLOR_FormatVendorMTKYUV: Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("OMX_COLOR_FormatVendorMTKYUV: Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eNV12_BLK);	
+    //    blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV_FCM) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+	ALOGD("Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eNV12_BLK_FCM);
+	//blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK_FCM, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    if (mSrcFormat == OMX_COLOR_Format32bitARGB8888) {
+	char* planar[1];
+	unsigned int length[1];
+	planar[0] = (char*)src.mBits;
+	length[0] = srcWStride*srcHStride*4;
+	ALOGD("OMX_COLOR_Format32bitARGB8888: Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("OMX_COLOR_Format32bitARGB8888: Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 1);
+        blitStream.setSrcConfig(srcWStride, srcHStride, eRGBA8888);
+    }
+
+
+    ALOGD("dst addr(%p), w(%d), h(%d)", dst.mBits, dstWStride, dstHStride);
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+	blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 2, 0);
+        blitStream.setDstConfig(dst.mWidth, dst.mHeight, eRGB565);
+      ALOGD("dst color format: OMX_COLOR_Format16bitRGB565");
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+	blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 4, 0);
+	blitStream.setDstConfig(dst.mWidth, dst.mHeight, eABGR8888);
+      ALOGD("dst color format: OMX_COLOR_Format32bitABGR8888");
+    }
+
+
+    // Add Sharpness in Video Thumbnail
+    blitStream.setTdshp(1);
+    bool bRet = blitStream.invalidate();
+    ALOGI("blitStream return %d.", bRet);
+
+	
+    if (!bRet)
+        return OK;
+    else
+    ALOGI("UNKNOWN ERROR");
+        return UNKNOWN_ERROR;
+
+    return OK;
+}
+
+
+status_t ColorConverter::convertYUV420PlanarToABGR8888(const BitmapParams &src, const BitmapParams &dst) {
+
+    ALOGD ("ColorConverter::convertYUV420PlanarToABGR8888(SW) src.cropWidth(%d), src.cropHeight(%d), dst.cropWidth(%d), dst.cropHeight(%d)",
+        src.cropWidth(), src.cropHeight(), dst.cropWidth(), dst.cropHeight());
+
+    if (!((src.mCropLeft & 1) == 0
+            && src.cropWidth() == dst.cropWidth()
+            && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint8_t *kAdjustedClip = initClip();
+
+    uint32_t *dst_ptr = (uint32_t *)dst.mBits + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+    
+    const uint8_t *src_y =  (const uint8_t *)src.mBits + src.mCropTop * src.mWidth + src.mCropLeft;
+
+    const uint8_t *src_u =
+       (const uint8_t *)src_y + src.mWidth * src.mHeight
+        + src.mCropTop * (src.mWidth / 2) + src.mCropLeft / 2;
+
+    const uint8_t *src_v =
+       src_u + (src.mWidth / 2) * (src.mHeight / 2);
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x++) {
+            signed y1 = (signed)src_y[x] - 16;
+            signed u = (signed)src_u[x / 2] - 128;
+            signed v = (signed)src_v[x / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+	    uint32_t rgb1 =
+                  (kAdjustedClip[r1] << 0)
+                | (kAdjustedClip[g1] << 8)
+                | (kAdjustedClip[b1] << 16)
+                | (0xFF << 24);
+                                               
+            dst_ptr[x] = rgb1;
+        }
+
+        src_y += src.mWidth;
+
+        if (y & 1) {
+            src_u += src.mWidth / 2;
+            src_v += src.mWidth / 2;
+        }
+
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/include/OMX.h b/media/libstagefright/include/OMX.h
index 829c38b59..83abfff12 100644
--- a/media/libstagefright/include/OMX.h
+++ b/media/libstagefright/include/OMX.h
@@ -83,6 +83,25 @@ public:
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer, OMX_BOOL crossProcess);
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer);
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer);
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap);
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase);
+
+  virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer);
+#endif
     virtual status_t useGraphicBuffer(
             node_id node, OMX_U32 port_index,
             const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer);
diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
index 616dda1a8..3813ddcc2 100644
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -75,6 +75,25 @@ struct OMXNodeInstance {
             OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
             OMX::buffer_id *buffer);
 
+#ifdef MTK_HARDWARE
+    status_t useBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, size_t size,
+            OMX::buffer_id *buffer);
+
+    status_t useBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            OMX::buffer_id *buffer);
+
+    status_t registerBuffer(
+            OMX_U32 portIndex, const sp<IMemoryHeap> &heap);
+
+    status_t registerBuffer2(
+            OMX_U32 portIndex, const sp<IMemoryHeap> &HeapBase);
+
+    status_t useIonBuffer(
+            OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, OMX::buffer_id *buffer);
+#endif
+
     status_t updateGraphicBufferInMeta(
             OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
             OMX::buffer_id buffer);
@@ -133,6 +152,9 @@ private:
     OMX::node_id mNodeID;
     OMX_HANDLETYPE mHandle;
     sp<IOMXObserver> mObserver;
+#ifdef MTK_HARDWARE
+    sp<IMemoryHeap> mHeap;
+#endif
     bool mDying;
     bool mSailed;  // configuration is set (no more meta-mode changes)
     bool mQueriedProhibitedExtensions;
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index 44080507c..26e96f265 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -37,6 +37,17 @@ ifeq ($(DTS_CODEC_M_), true)
   LOCAL_CFLAGS += -DDTS_CODEC_M_
 endif
 
+
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+        $(TOP)/frameworks/av/media/libstagefright/include \
+        $(TOP)/mediatek/frameworks/av/media/libstagefright/include
+
+    LOCAL_SHARED_LIBRARIES += \
+        libstagefright_memutil
+
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index 390c6bed3..c0d6feb2b 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -391,6 +391,39 @@ status_t OMX::signalEndOfInputStream(node_id node) {
     return findInstance(node)->signalEndOfInputStream();
 }
 
+#ifdef MTK_HARDWARE
+ status_t OMX::useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) {
+    return findInstance(node)->useBuffer(
+            port_index, virAddr, size, buffer);
+}
+
+status_t OMX::useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) {
+    return findInstance(node)->useBuffer(
+            port_index, virAddr, size, offset, buffer);
+}
+
+status_t OMX::registerBuffer(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+    return findInstance(node)->registerBuffer(
+            port_index, heap);
+}
+
+status_t OMX::registerBuffer2(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) {
+    return findInstance(node)->registerBuffer2(
+            port_index, HeapBase);
+}
+
+status_t OMX::useIonBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+    return findInstance(node)->useIonBuffer(
+            port_index, virAddr, fd, size, buffer);
+}
+#endif
 status_t OMX::allocateBuffer(
         node_id node, OMX_U32 port_index, size_t size,
         buffer_id *buffer, void **buffer_data) {
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 9d384c5df..1faf0ff79 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -35,6 +35,25 @@
 #include <media/stagefright/MediaErrors.h>
 
 #include <utils/misc.h>
+#ifdef MTK_HARDWARE
+#include "sf_mem_util.h"
+#define USE_VIDEO_M4U
+
+struct UseIonBufferParams {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_PTR pAppPrivate;
+    unsigned char* virAddr;
+    OMX_S32 Ionfd;
+    size_t size;
+    OMX_BUFFERHEADERTYPE **bufferHeader;
+};
+
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+#endif
+
 
 static const OMX_U32 kPortIndexInput = 0;
 static const OMX_U32 kPortIndexOutput = 1;
@@ -157,7 +176,12 @@ struct BufferMeta {
     ~BufferMeta() {
         delete[] mBackup;
     }
-
+#ifdef MTK_HARDWARE
+    sp<IMemory> GetMem()
+    {
+        return mMem;
+    }
+#endif
 private:
     sp<GraphicBuffer> mGraphicBuffer;
     sp<IMemory> mMem;
@@ -191,6 +215,9 @@ OMXNodeInstance::OMXNodeInstance(
       mNodeID(0),
       mHandle(NULL),
       mObserver(observer),
+#ifdef MTK_HARDWARE
+      mHeap(NULL),
+#endif
       mDying(false),
       mSailed(false),
       mQueriedProhibitedExtensions(false),
@@ -212,6 +239,14 @@ OMXNodeInstance::OMXNodeInstance(
 OMXNodeInstance::~OMXNodeInstance() {
     free(mName);
     CHECK(mHandle == NULL);
+
+#ifdef MTK_HARDWARE
+    if (mHeap != NULL)
+    {
+        sf_memheap_remove_info (mHeap->getBase());
+        mHeap = NULL;
+    }
+#endif
 }
 
 void OMXNodeInstance::setHandle(OMX::node_id node_id, OMX_HANDLETYPE handle) {
@@ -794,6 +829,193 @@ status_t OMXNodeInstance::useBuffer(
     return OK;
 }
 
+#ifdef MTK_HARDWARE
+status_t OMXNodeInstance::useBuffer(
+         OMX_U32 portIndex, unsigned char* virAddr, size_t size,
+        OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+
+    BufferMeta *buffer_meta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    //ALOGE ("@@ OMX_UseBuffer2 virAddr=0x%x", virAddr);
+    
+    OMX_ERRORTYPE err = OMX_UseBuffer(
+            mHandle, &header, portIndex, buffer_meta,
+            size, static_cast<OMX_U8 *>(virAddr));
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
+
+        delete buffer_meta;
+        buffer_meta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+ }
+
+ status_t OMXNodeInstance::useBuffer(
+        OMX_U32 portIndex, unsigned char* virAddr, size_t size, OMX_U32 offset,
+        OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+    unsigned char *vAddr = virAddr;
+
+    if (mHeap == NULL) 
+        return UNKNOWN_ERROR;
+
+    BufferMeta *buffer_meta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    void *base = mHeap->getBase();
+    vAddr = (unsigned char *)base + offset;
+
+// Morris Yang alignment patch [
+#ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    unsigned char* ptr = reinterpret_cast<unsigned char*>(base);
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+    vAddr = (unsigned char *)(pBuffer+offset);
+#else
+    // do nothing
+#endif
+    ALOGD ("@@ useBuffer[OUT] ptr(0x%08X), pBuffer(0x%08X), vAddr(0x%08X)", ptr, pBuffer, vAddr);
+// ]
+
+    OMX_ERRORTYPE err = OMX_UseBuffer(
+            mHandle, &header, portIndex, buffer_meta,
+            size, static_cast<OMX_U8 *>(vAddr));
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
+
+        delete buffer_meta;
+        buffer_meta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+ }
+
+status_t OMXNodeInstance::registerBuffer(
+        OMX_U32 portIndex, const sp<IMemoryHeap> &heap) {
+    Mutex::Autolock autoLock(mLock);
+
+    // Unregister pmem
+    if (mHeap != NULL)
+    {
+        ExPmemInfo rInfo;
+        rInfo.base = mHeap->getBase();
+        rInfo.size = mHeap->getSize();
+        rInfo.shared_fd = mHeap->getHeapID();
+        rInfo.offset = 0;
+
+        if (!sf_pmem_unregister(&rInfo)) {
+            ALOGE("pmem unregister err: 0x%X, offset: 0x%X !", (unsigned)rInfo.base, rInfo.offset);
+        }
+        mHeap = NULL;
+    }
+
+    mHeap = heap;
+
+    // Register pmem
+    ExPmemInfo rInfo;
+    rInfo.base = mHeap->getBase();
+    rInfo.size = mHeap->getSize();
+    rInfo.shared_fd = mHeap->getHeapID();
+    rInfo.offset = 0;
+    if (!sf_pmem_register(&rInfo)) {
+        ALOGE("pmem register err: 0x%X, offset: 0x%X !", (unsigned)rInfo.base, rInfo.offset);
+    }
+
+    return OK;
+}
+
+status_t OMXNodeInstance::registerBuffer2(
+        OMX_U32 portIndex, const sp<IMemoryHeap> &HeapBase) {
+    Mutex::Autolock autoLock(mLock);
+
+    MemHeapInfo memheapinfo;
+
+    mHeap = HeapBase;
+    memheapinfo.base = (unsigned char*) mHeap->getBase();
+    memheapinfo.mMemHeapBase = (int) mHeap.get();
+    memheapinfo.size = mHeap->getSize();
+    ALOGD("registerBuffer2: base = 0x%08X, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo.base, (unsigned int)memheapinfo.mMemHeapBase, (unsigned int)memheapinfo.size);
+    sf_memheap_set_info(&memheapinfo);
+
+    return OK;
+}
+
+status_t OMXNodeInstance::useIonBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, OMX_S32 fd, size_t size, OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+
+    OMX_INDEXTYPE index;
+    OMX_ERRORTYPE err = OMX_GetExtensionIndex(
+            mHandle,
+            const_cast<OMX_STRING>("OMX.MTK.VIDEO.index.useIonBuffer"),
+            &index);
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_GetExtensionIndex failed");
+
+        return StatusFromOMXError(err);
+}
+
+    BufferMeta *bufferMeta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    OMX_VERSIONTYPE ver;
+    ver.s.nVersionMajor = 1;
+    ver.s.nVersionMinor = 0;
+    ver.s.nRevision = 0;
+    ver.s.nStep = 0;
+
+    UseIonBufferParams params = {
+        sizeof(UseIonBufferParams), ver, portIndex, bufferMeta,
+        virAddr, fd, size, &header
+    };
+    
+    err = OMX_SetParameter(mHandle, index, &params);
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseAndroidNativeBuffer failed with error %d (0x%08x)", err,
+                err);
+
+        delete bufferMeta;
+        bufferMeta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    CHECK_EQ(header->pAppPrivate, bufferMeta);
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+}
+#endif
 status_t OMXNodeInstance::useGraphicBuffer2_l(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id *buffer) {
@@ -853,12 +1075,15 @@ status_t OMXNodeInstance::useGraphicBuffer(
 
     // See if the newer version of the extension is present.
     OMX_INDEXTYPE index;
+
+#ifndef MTK_HARDWARE
     if (OMX_GetExtensionIndex(
             mHandle,
             const_cast<OMX_STRING>("OMX.google.android.index.useAndroidNativeBuffer2"),
             &index) == OMX_ErrorNone) {
         return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);
     }
+#endif
 
     OMX_STRING name = const_cast<OMX_STRING>(
         "OMX.google.android.index.useAndroidNativeBuffer");
diff --git a/services/audioflinger/Android.mk b/services/audioflinger/Android.mk
index 4eb13a316..460112384 100644
--- a/services/audioflinger/Android.mk
+++ b/services/audioflinger/Android.mk
@@ -93,6 +93,13 @@ endif
 endif
 #QTI Resampler
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+   LOCAL_SRC_FILES += \
+        AudioResamplermtk.cpp
+
+    LOCAL_SHARED_LIBRARIES += libblisrc
+endif
+
 LOCAL_MODULE:= libaudioflinger
 LOCAL_32_BIT_ONLY := true
 
@@ -109,6 +116,14 @@ else
     LOCAL_CFLAGS += -DANDROID_SMP=0
 endif
 
+ifeq ($(BOARD_HAVE_PRE_KITKAT_AUDIO_BLOB),true)
+    LOCAL_CFLAGS += -DHAVE_PRE_KITKAT_AUDIO_BLOB
+endif
+
+ifeq ($(BOARD_HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB),true)
+    LOCAL_CFLAGS += -DHAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+endif
+
 LOCAL_CFLAGS += -fvisibility=hidden
 
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_HDMI_PASSTHROUGH)),true)
@@ -154,6 +169,12 @@ LOCAL_SHARED_LIBRARIES := \
     libutils \
     liblog
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+   LOCAL_SRC_FILES += \
+        AudioResamplermtk.cpp
+    LOCAL_SHARED_LIBRARIES += libblisrc
+endif
+
 LOCAL_MODULE:= test-resample
 
 LOCAL_MODULE_TAGS := optional
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 0c9b646b0..dd19ea371 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -137,6 +137,29 @@ size_t AudioFlinger::mTeeSinkTrackFrames = kTeeSinkTrackFramesDefault;
 static const nsecs_t kMinGlobalEffectEnabletimeNs = seconds(7200);
 
 // ----------------------------------------------------------------------------
+#ifdef MTK_HARDWARE
+status_t AudioFlinger::SetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("SetAudioData par1 = %d,len = %d ",par1,len);
+    AutoMutex lock(mHardwareLock);
+    audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("GetAudioData par1 = %d,len = %d ",par1,len);
+    AutoMutex lock(mHardwareLock);
+    audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->GetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+#endif
 
 const char *formatToString(audio_format_t format) {
     switch (format & AUDIO_FORMAT_MAIN_MASK) {
@@ -1151,6 +1174,18 @@ status_t AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value,
         thread->setStreamVolume(stream, value);
     }
 
+#ifdef MTK_HARDWARE
+    // MTK FM Volume
+    if(stream == AUDIO_STREAM_MUSIC) {
+        sp<ThreadBase> thread;
+        thread = checkPlaybackThread_l(output);
+        if (thread == primaryPlaybackThread_l()) {
+            audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+            dev->set_parameters (dev, String8::format("SetFmVolume=%f", value));
+        }
+    }
+#endif
+
     return NO_ERROR;
 }
 
@@ -1952,6 +1987,20 @@ status_t AudioFlinger::setLowRamDevice(bool isLowRamDevice)
     return NO_ERROR;
 }
 
+#ifdef HAVE_PRE_KITKAT_AUDIO_BLOB
+audio_io_handle_t AudioFlinger::openOutput(audio_module_handle_t module,
+                                           audio_devices_t *pDevices,
+                                           uint32_t *pSamplingRate,
+                                           audio_format_t *pFormat,
+                                           audio_channel_mask_t *pChannelMask,
+                                           uint32_t *pLatencyMs,
+                                           audio_output_flags_t flags)
+{
+    return openOutput(module, pDevices, pSamplingRate, pFormat, pChannelMask,
+            pLatencyMs, flags);
+}
+#endif
+
 audio_hw_sync_t AudioFlinger::getAudioHwSyncForSession(audio_session_t sessionId)
 {
     Mutex::Autolock _l(mLock);
@@ -2393,7 +2442,9 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
     // resample the input and do mono to stereo or stereo to mono conversions on 16 bit PCM inputs.
     if (status == BAD_VALUE &&
             config->format == halconfig.format && halconfig.format == AUDIO_FORMAT_PCM_16_BIT &&
+#ifndef MTK_HARDWARE
         (halconfig.sample_rate <= 2 * config->sample_rate) &&
+#endif
         (audio_channel_count_from_in_mask(halconfig.channel_mask) <= FCC_2) &&
         (audio_channel_count_from_in_mask(config->channel_mask) <= FCC_2)) {
         // FIXME describe the change proposed by HAL (save old values so we can log them here)
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 60eed29bf..de57b1540 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -124,6 +124,11 @@ class AudioFlinger :
 public:
     static const char* getServiceName() ANDROID_API { return "media.audio_flinger"; }
 
+#ifdef MTK_HARDWARE
+    virtual status_t SetAudioData(int par1,size_t len, void *ptr);
+    virtual status_t GetAudioData(int par1,size_t len, void *ptr);
+#endif
+
     virtual     status_t    dump(int fd, const Vector<String16>& args);
 
     // IAudioFlinger interface, in binder opcode order
@@ -202,6 +207,16 @@ public:
     virtual     size_t      getInputBufferSize(uint32_t sampleRate, audio_format_t format,
                                                audio_channel_mask_t channelMask) const;
 
+#ifdef HAVE_PRE_KITKAT_AUDIO_BLOB
+    virtual audio_io_handle_t openOutput(audio_module_handle_t module,
+                                         audio_devices_t *pDevices,
+                                         uint32_t *pSamplingRate,
+                                         audio_format_t *pFormat,
+                                         audio_channel_mask_t *pChannelMask,
+                                         uint32_t *pLatencyMs,
+                                         audio_output_flags_t flags);
+#endif
+
     virtual status_t openOutput(audio_module_handle_t module,
                                 audio_io_handle_t *output,
                                 audio_config_t *config,
diff --git a/services/audioflinger/AudioResampler.cpp b/services/audioflinger/AudioResampler.cpp
index 0f4eaa58e..480e99a23 100644
--- a/services/audioflinger/AudioResampler.cpp
+++ b/services/audioflinger/AudioResampler.cpp
@@ -27,6 +27,9 @@
 #include "AudioResamplerSinc.h"
 #include "AudioResamplerCubic.h"
 #include "AudioResamplerDyn.h"
+#ifdef MTK_HARDWARE
+#include "AudioResamplermtk.h"
+#endif
 
 #ifdef QTI_RESAMPLER
 #include "AudioResamplerQTI.h"
@@ -39,14 +42,22 @@
 namespace android {
 
 #ifdef __ARM_HAVE_HALFWORD_MULTIPLY // optimized asm option
+#ifndef MTK_HARDWARE
     #define ASM_ARM_RESAMP1 // enable asm optimisation for ResamplerOrder1
+#endif
 #endif // __ARM_HAVE_HALFWORD_MULTIPLY
 // ----------------------------------------------------------------------------
 
 class AudioResamplerOrder1 : public AudioResampler {
 public:
+//#ifdef MTK_AUDIO
+    AudioResamplerOrder1(int bitDepth, int inChannelCount, int32_t sampleRate) :
+        AudioResampler(bitDepth, inChannelCount, sampleRate, LOW_QUALITY), mX0L(0), mX0R(0) {
+            }
+//#else
     AudioResamplerOrder1(int inChannelCount, int32_t sampleRate) :
         AudioResampler(inChannelCount, sampleRate, LOW_QUALITY), mX0L(0), mX0R(0) {
+//#endif
     }
     virtual void resample(int32_t* out, size_t outFrameCount,
             AudioBufferProvider* provider);
@@ -57,7 +68,11 @@ private:
     // bits to shift the phase fraction down to avoid overflow
     static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits;
 
+//#ifndef MTK_AUDIO
     void init() {}
+//#else
+    void init(int32_t SrcSampleRate) {}
+//#endif
     void resampleMono16(int32_t* out, size_t outFrameCount,
             AudioBufferProvider* provider);
     void resampleStereo16(int32_t* out, size_t outFrameCount,
@@ -142,6 +157,10 @@ uint32_t AudioResampler::qualityMHz(src_quality quality)
         return 6;
     case HIGH_QUALITY:
         return 20;
+#ifdef MTK_HARDWARE
+    case MTK_QUALITY:
+        return 28;
+#endif
     case VERY_HIGH_QUALITY:
 #ifdef QTI_RESAMPLER
     case QTI_QUALITY: //for QTI_QUALITY, currently assuming same as VHQ
@@ -160,8 +179,10 @@ static const uint32_t maxMHz = 130; // an arbitrary number that permits 3 VHQ, s
 static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
 static uint32_t currentMHz = 0;
 
-AudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount,
-        int32_t sampleRate, src_quality quality) {
+//#ifdef MTK_AUDIO
+AudioResampler* AudioResampler::create(int format, int inChannelCount,
+        int32_t sampleRate, src_quality quality, int32_t SrcSampleRate) {
+//#endif
 
     bool atFinalQuality;
     if (quality == DEFAULT_QUALITY) {
@@ -201,6 +222,9 @@ AudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount
         switch (quality) {
         default:
         case LOW_QUALITY:
+#ifdef MTK_HARDWARE
+        case MTK_QUALITY:
+#endif
             atFinalQuality = true;
             break;
         case MED_QUALITY:
@@ -237,22 +261,38 @@ AudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount
     case LOW_QUALITY:
         ALOGV("Create linear Resampler");
         LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+#ifdef MTK_HARDWARE
+        resampler = new AudioResamplerOrder1(format, inChannelCount, sampleRate);
+        #else
         resampler = new AudioResamplerOrder1(inChannelCount, sampleRate);
+        #endif
         break;
     case MED_QUALITY:
         ALOGV("Create cubic Resampler");
         LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+#ifdef MTK_HARDWARE
+        resampler = new AudioResamplerCubic(format, inChannelCount, sampleRate);
+        #else
         resampler = new AudioResamplerCubic(inChannelCount, sampleRate);
+        #endif
         break;
     case HIGH_QUALITY:
         ALOGV("Create HIGH_QUALITY sinc Resampler");
         LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+#ifdef MTK_HARDWARE
+        resampler = new AudioResamplerSinc(format, inChannelCount, sampleRate);
+        #else
         resampler = new AudioResamplerSinc(inChannelCount, sampleRate);
+        #endif
         break;
     case VERY_HIGH_QUALITY:
         ALOGV("Create VERY_HIGH_QUALITY sinc Resampler = %d", quality);
         LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+#ifdef MTK_HARDWARE
+        resampler = new AudioResamplerSinc(format, inChannelCount, sampleRate);
+        #else
         resampler = new AudioResamplerSinc(inChannelCount, sampleRate, quality);
+        #endif
         break;
     case DYN_LOW_QUALITY:
     case DYN_MED_QUALITY:
@@ -278,18 +318,195 @@ AudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount
         resampler = new AudioResamplerQTI(format, inChannelCount, sampleRate);
         break;
 #endif
+#if 0//def MTK_AUDIO
+    case MTK_QUALITY:
+        ALOGD("Create MTK Resampler");
+        resampler = new AudioResamplerMtk(format, inChannelCount, sampleRate);
+        break;
+    case MTK_QUALITY_32BIT:
+        ALOGD("Create MTK Resampler");
+#ifdef MTK_HD_AUDIO_ARCHITECTURE
+        resampler = new AudioResamplerMtk32(format, inChannelCount, sampleRate);
+#else
+        resampler = new AudioResamplerMtk(format, inChannelCount, sampleRate);
+#endif
+        break;
+#endif // MTK_AUDIO
+    }
+
+    // initialize resampler
+#ifndef MTK_HARDWARE
+    resampler->init();
+#else
+    resampler->init(SrcSampleRate);
+#endif
+    return resampler;
+}
+//#else
+AudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount,
+        int32_t sampleRate, src_quality quality) {
+//#endif
+    bool atFinalQuality;
+    if (quality == DEFAULT_QUALITY) {
+        // read the resampler default quality property the first time it is needed
+        int ok = pthread_once(&once_control, init_routine);
+        if (ok != 0) {
+            ALOGE("%s pthread_once failed: %d", __func__, ok);
+        }
+        quality = defaultQuality;
+        atFinalQuality = false;
+    } else {
+        atFinalQuality = true;
+    }
+
+    /* if the caller requests DEFAULT_QUALITY and af.resampler.property
+     * has not been set, the target resampler quality is set to DYN_MED_QUALITY,
+     * and allowed to "throttle" down to DYN_LOW_QUALITY if necessary
+     * due to estimated CPU load of having too many active resamplers
+     * (the code below the if).
+     */
+    if (quality == DEFAULT_QUALITY) {
+        quality = DYN_MED_QUALITY;
+    }
+
+    // naive implementation of CPU load throttling doesn't account for whether resampler is active
+    pthread_mutex_lock(&mutex);
+    for (;;) {
+        uint32_t deltaMHz = qualityMHz(quality);
+        uint32_t newMHz = currentMHz + deltaMHz;
+        if ((qualityIsSupported(quality) && newMHz <= maxMHz) || atFinalQuality) {
+            ALOGV("resampler load %u -> %u MHz due to delta +%u MHz from quality %d",
+                    currentMHz, newMHz, deltaMHz, quality);
+            currentMHz = newMHz;
+            break;
+        }
+        // not enough CPU available for proposed quality level, so try next lowest level
+        switch (quality) {
+        default:
+        case LOW_QUALITY:
+            atFinalQuality = true;
+            break;
+        case MED_QUALITY:
+            quality = LOW_QUALITY;
+            break;
+        case HIGH_QUALITY:
+            quality = MED_QUALITY;
+            break;
+        case VERY_HIGH_QUALITY:
+            quality = HIGH_QUALITY;
+            break;
+        case DYN_LOW_QUALITY:
+            atFinalQuality = true;
+            break;
+        case DYN_MED_QUALITY:
+            quality = DYN_LOW_QUALITY;
+            break;
+        case DYN_HIGH_QUALITY:
+            quality = DYN_MED_QUALITY;
+            break;
+        }
+    }
+    pthread_mutex_unlock(&mutex);
+
+    AudioResampler* resampler;
+
+    switch (quality) {
+    default:
+    case LOW_QUALITY:
+        ALOGV("Create linear Resampler");
+        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+       // #ifdef MTK_AUDIO        
+        //resampler = new AudioResamplerOrder1(format, inChannelCount, sampleRate);
+        //#else
+        resampler = new AudioResamplerOrder1(inChannelCount, sampleRate);
+        //#endif
+        break;
+    case MED_QUALITY:
+        ALOGV("Create cubic Resampler");
+        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+        //#ifdef MTK_AUDIO        
+       // resampler = new AudioResamplerCubic(format, inChannelCount, sampleRate);
+        //#else
+        resampler = new AudioResamplerCubic(inChannelCount, sampleRate);
+        //#endif
+        break;
+    case HIGH_QUALITY:
+        ALOGV("Create HIGH_QUALITY sinc Resampler");
+        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+        //#ifdef MTK_AUDIO        
+        //resampler = new AudioResamplerSinc(format, inChannelCount, sampleRate);
+       // #else
+        resampler = new AudioResamplerSinc(inChannelCount, sampleRate);
+       // #endif
+        break;
+    case VERY_HIGH_QUALITY:
+        ALOGV("Create VERY_HIGH_QUALITY sinc Resampler = %d", quality);
+        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+        //#ifdef MTK_AUDIO        
+        //resampler = new AudioResamplerSinc(format, inChannelCount, sampleRate);
+        //#else
+        resampler = new AudioResamplerSinc(inChannelCount, sampleRate, quality);
+       // #endif
+        break;
+    case DYN_LOW_QUALITY:
+    case DYN_MED_QUALITY:
+    case DYN_HIGH_QUALITY:
+        ALOGV("Create dynamic Resampler = %d", quality);
+        if (format == AUDIO_FORMAT_PCM_FLOAT) {
+            resampler = new AudioResamplerDyn<float, float, float>(inChannelCount,
+                    sampleRate, quality);
+        } else {
+            LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT);
+            if (quality == DYN_HIGH_QUALITY) {
+                resampler = new AudioResamplerDyn<int32_t, int16_t, int32_t>(inChannelCount,
+                        sampleRate, quality);
+            } else {
+                resampler = new AudioResamplerDyn<int16_t, int16_t, int32_t>(inChannelCount,
+                        sampleRate, quality);
+            }
+        }
+        break;
     }
 
     // initialize resampler
+//#ifndef MTK_AUDIO 
     resampler->init();
+//#else
+//    resampler->init(SrcSampleRate);
+//#endif
     return resampler;
 }
+//#ifdef MTK_AUDIO 
+AudioResampler::AudioResampler(int format, int inChannelCount,
+        int32_t sampleRate, src_quality quality) :
+    mBitDepth(format), mChannelCount(inChannelCount),
+        mSampleRate(sampleRate), mInSampleRate(sampleRate), mInputIndex(0),
+        mPhaseFraction(0), mLocalTimeFreq(0),
+        mPTS(AudioBufferProvider::kInvalidPTS), mQuality(quality) {
+
+    const int maxChannels = quality < DYN_LOW_QUALITY ? 2 : 8;
+    if ( ((format != 16)&&(format != 24)&&(format != 32)) ||(inChannelCount < 1) || (inChannelCount > 2)) {
+        LOG_ALWAYS_FATAL("Unsupported sample format %d quality %d channels",
+                quality, inChannelCount);
+    }
+    if (sampleRate <= 0) {
+        LOG_ALWAYS_FATAL("Unsupported sample rate %d Hz", sampleRate);
+    }
+
+    // initialize common members
+    mVolume[0] = mVolume[1] = 0;
+    mBuffer.frameCount = 0;
+}
+//#endif
 
 AudioResampler::AudioResampler(int inChannelCount,
         int32_t sampleRate, src_quality quality) :
         mChannelCount(inChannelCount),
         mSampleRate(sampleRate), mInSampleRate(sampleRate), mInputIndex(0),
         mPhaseFraction(0), mLocalTimeFreq(0),
+            //#ifdef MTK_AUDIO
+            mBitDepth(16),
+            //#endif
         mPTS(AudioBufferProvider::kInvalidPTS), mQuality(quality) {
 
     const int maxChannels = quality < DYN_LOW_QUALITY ? 2 : 8;
diff --git a/services/audioflinger/AudioResampler.h b/services/audioflinger/AudioResampler.h
index 54130c4eb..8bd91e5b7 100644
--- a/services/audioflinger/AudioResampler.h
+++ b/services/audioflinger/AudioResampler.h
@@ -47,6 +47,9 @@ public:
         DYN_HIGH_QUALITY=7,
 #ifdef QTI_RESAMPLER
         QTI_QUALITY=8,
+#endif
+#ifdef MTK_HARDWARE
+        MTK_QUALITY=8,
 #endif
     };
 
@@ -54,10 +57,16 @@ public:
 
     static AudioResampler* create(audio_format_t format, int inChannelCount,
             int32_t sampleRate, src_quality quality=DEFAULT_QUALITY);
+//#else
+    static AudioResampler* create(int bitDepth, int inChannelCount,
+            int32_t sampleRate, src_quality quality=DEFAULT_QUALITY, int32_t SrcSampleRate=0);
 
     virtual ~AudioResampler();
 
     virtual void init() = 0;
+//#else
+    virtual void init(int32_t SrcSampleRate) = 0;
+//#endif
     virtual void setSampleRate(int32_t inSampleRate);
     virtual void setVolume(float left, float right);
     virtual void setLocalTimeFreq(uint64_t freq);
@@ -94,12 +103,18 @@ protected:
 
     AudioResampler(int inChannelCount, int32_t sampleRate, src_quality quality);
 
+//#else
+    AudioResampler(int bitDepth, int inChannelCount, int32_t sampleRate, src_quality quality);
+//#endif
     // prevent copying
     AudioResampler(const AudioResampler&);
     AudioResampler& operator=(const AudioResampler&);
 
     int64_t calculateOutputPTS(int outputFrameIndex);
 
+//#ifdef MTK_AUDIO
+    const int32_t mBitDepth;
+//#endif
     const int32_t mChannelCount;
     const int32_t mSampleRate;
     int32_t mInSampleRate;
diff --git a/services/audioflinger/AudioResamplerCubic.cpp b/services/audioflinger/AudioResamplerCubic.cpp
index 8f14ff917..8659c5dbd 100644
--- a/services/audioflinger/AudioResamplerCubic.cpp
+++ b/services/audioflinger/AudioResamplerCubic.cpp
@@ -26,8 +26,15 @@
 
 namespace android {
 // ----------------------------------------------------------------------------
+//#ifdef MTK_AUDIO
+void AudioResamplerCubic::init(int32_t SrcSampleRate) {
+        memset(&left, 0, sizeof(state));
+        memset(&right, 0, sizeof(state));
+    }
 
+//#else
 void AudioResamplerCubic::init() {
+//#endif
     memset(&left, 0, sizeof(state));
     memset(&right, 0, sizeof(state));
 }
diff --git a/services/audioflinger/AudioResamplerCubic.h b/services/audioflinger/AudioResamplerCubic.h
index b315da52f..b975d0f13 100644
--- a/services/audioflinger/AudioResamplerCubic.h
+++ b/services/audioflinger/AudioResamplerCubic.h
@@ -28,8 +28,14 @@ namespace android {
 
 class AudioResamplerCubic : public AudioResampler {
 public:
+//#ifdef MTK_AUDIO
+    AudioResamplerCubic(int bitDepth, int inChannelCount, int32_t sampleRate) :
+        AudioResampler(bitDepth, inChannelCount, sampleRate, MED_QUALITY) {
+            }
+//#else
     AudioResamplerCubic(int inChannelCount, int32_t sampleRate) :
         AudioResampler(inChannelCount, sampleRate, MED_QUALITY) {
+//#endif
     }
     virtual void resample(int32_t* out, size_t outFrameCount,
             AudioBufferProvider* provider);
@@ -42,7 +48,11 @@ private:
     typedef struct {
         int32_t a, b, c, y0, y1, y2, y3;
     } state;
+//#ifdef MTK_AUDIO
+    void init(int32_t SrcSampleRate);
+//#else
     void init();
+//#endif
     void resampleMono16(int32_t* out, size_t outFrameCount,
             AudioBufferProvider* provider);
     void resampleStereo16(int32_t* out, size_t outFrameCount,
diff --git a/services/audioflinger/AudioResamplerDyn.cpp b/services/audioflinger/AudioResamplerDyn.cpp
index 0eeb201d8..a5b6bc2db 100644
--- a/services/audioflinger/AudioResamplerDyn.cpp
+++ b/services/audioflinger/AudioResamplerDyn.cpp
@@ -190,6 +190,14 @@ void AudioResamplerDyn<TC, TI, TO>::init()
     mInBuffer.init();
 }
 
+//#ifdef MTK_AUDIO
+template<typename TC, typename TI, typename TO>
+void AudioResamplerDyn<TC, TI, TO>::init(int32_t SrcSampleRate)
+    {
+        mFilterSampleRate = 0; // always trigger new filter generation
+        mInBuffer.init();
+    }
+//#endif
 template<typename TC, typename TI, typename TO>
 void AudioResamplerDyn<TC, TI, TO>::setVolume(float left, float right)
 {
@@ -311,6 +319,7 @@ void AudioResamplerDyn<TC, TI, TO>::setSampleRate(int32_t inSampleRate)
             // 32b coefficients, 64 length
             useS32 = true;
             stopBandAtten = 98.;
+#ifndef MTK_HARDWARE
             if (inSampleRate >= mSampleRate * 4) {
                 halfLength = 48;
             } else if (inSampleRate >= mSampleRate * 2) {
@@ -318,6 +327,16 @@ void AudioResamplerDyn<TC, TI, TO>::setSampleRate(int32_t inSampleRate)
             } else {
                 halfLength = 32;
             }
+#else
+            if (inSampleRate >= mSampleRate * 4) {
+                halfLength = 96;
+                tbwCheat = 1.1;
+            } else if (inSampleRate >= mSampleRate * 2) {
+                halfLength = 40;
+            } else {
+                halfLength = 48;
+            }
+#endif        
         } else if (mFilterQuality == DYN_LOW_QUALITY) {
             // 16b coefficients, 16-32 length
             useS32 = false;
diff --git a/services/audioflinger/AudioResamplerDyn.h b/services/audioflinger/AudioResamplerDyn.h
index e886a681c..10c9bdb00 100644
--- a/services/audioflinger/AudioResamplerDyn.h
+++ b/services/audioflinger/AudioResamplerDyn.h
@@ -48,6 +48,9 @@ public:
 
     virtual void init();
 
+//#ifdef MTK_AUDIO
+    virtual void init(int32_t SrcSampleRate);
+//#endif
     virtual void setSampleRate(int32_t inSampleRate);
 
     virtual void setVolume(float left, float right);
diff --git a/services/audioflinger/AudioResamplerSinc.cpp b/services/audioflinger/AudioResamplerSinc.cpp
index d03e578a5..4cc865d12 100644
--- a/services/audioflinger/AudioResamplerSinc.cpp
+++ b/services/audioflinger/AudioResamplerSinc.cpp
@@ -452,10 +452,45 @@ int32_t mulAddRL(int left, uint32_t inRL, int32_t v, int32_t a)
 }
 
 // ----------------------------------------------------------------------------
+//#ifdef MTK_AUDIO
+AudioResamplerSinc::AudioResamplerSinc(int bitDepth,
+    int inChannelCount, int32_t sampleRate, src_quality quality)
+    : AudioResampler(bitDepth, inChannelCount, sampleRate, quality),    
+    mState(0), mImpulse(0), mRingFull(0), mFirCoefs(0)
+{
+    /*
+     * Layout of the state buffer for 32 tap:
+     *
+     * "present" sample            beginning of 2nd buffer
+     *                 v                v
+     *  0              01               2              23              3
+     *  0              F0               0              F0              F
+     * [pppppppppppppppInnnnnnnnnnnnnnnnpppppppppppppppInnnnnnnnnnnnnnnn]
+     *                 ^               ^ head
+     *
+     * p = past samples, convoluted with the (p)ositive side of sinc()
+     * n = future samples, convoluted with the (n)egative side of sinc()
+     * r = extra space for implementing the ring buffer
+     *
+     */
+
+    mVolumeSIMD[0] = 0;
+    mVolumeSIMD[1] = 0;
 
+    // Load the constants for coefficients
+    int ok = pthread_once(&once_control, init_routine);
+    if (ok != 0) {
+        ALOGE("%s pthread_once failed: %d", __func__, ok);
+    }
+    mConstants = (quality == VERY_HIGH_QUALITY) ?
+            &veryHighQualityConstants : &highQualityConstants;
+}
+//#else
 AudioResamplerSinc::AudioResamplerSinc(
+//#endif
         int inChannelCount, int32_t sampleRate, src_quality quality)
     : AudioResampler(inChannelCount, sampleRate, quality),
+//#endif
     mState(0), mImpulse(0), mRingFull(0), mFirCoefs(0)
 {
     /*
@@ -491,7 +526,19 @@ AudioResamplerSinc::~AudioResamplerSinc() {
     free(mState);
 }
 
+//#ifdef MTK_AUDIO
+void AudioResamplerSinc::init(int32_t SrcSampleRate) {
+    const Constants& c(*mConstants);
+    const size_t numCoefs = 2 * c.halfNumCoefs;
+    const size_t stateSize = numCoefs * mChannelCount * 2;
+    mState = (int16_t*)memalign(32, stateSize*sizeof(int16_t));
+    memset(mState, 0, sizeof(int16_t)*stateSize);
+    mImpulse  = mState   + (c.halfNumCoefs-1)*mChannelCount;
+    mRingFull = mImpulse + (numCoefs+1)*mChannelCount;
+}
+//#else
 void AudioResamplerSinc::init() {
+//#endif
     const Constants& c(*mConstants);
     const size_t numCoefs = 2 * c.halfNumCoefs;
     const size_t stateSize = numCoefs * mChannelCount * 2;
diff --git a/services/audioflinger/AudioResamplerSinc.h b/services/audioflinger/AudioResamplerSinc.h
index 4691d0a15..889f289a5 100644
--- a/services/audioflinger/AudioResamplerSinc.h
+++ b/services/audioflinger/AudioResamplerSinc.h
@@ -34,6 +34,10 @@ typedef int32_t (*readResampleFirLerpIntBitsFn)();
 
 class AudioResamplerSinc : public AudioResampler {
 public:
+//#ifdef MTK_AUDIO
+    AudioResamplerSinc(int bitDepth, int inChannelCount, int32_t sampleRate,
+    src_quality quality = HIGH_QUALITY);
+//#else
     AudioResamplerSinc(int inChannelCount, int32_t sampleRate,
             src_quality quality = HIGH_QUALITY);
 
@@ -42,8 +46,12 @@ public:
     virtual void resample(int32_t* out, size_t outFrameCount,
             AudioBufferProvider* provider);
 private:
+//#ifdef MTK_AUDIO
+    void init(int32_t SrcSampleRate);
+//#else
     void init();
 
+//#endif
     virtual void setVolume(float left, float right);
 
     template<int CHANNELS>
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index b8e27e2f8..927103f2b 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -97,6 +97,10 @@
 #include "postpro_patch.h"
 #endif
 
+#ifdef MTK_HARDWARE
+#include "AudioResamplermtk.h"
+#endif
+
 // ----------------------------------------------------------------------------
 
 // Note: the following macro is used for extremely verbose logging message.  In
@@ -363,6 +367,17 @@ static void sFastTrackMultiplierInit()
     }
 }
 
+#ifdef MTK_HARDWARE
+void inline MTK_downmix_to_mono_i16_from_stereo_i16(int16_t *dst, const int16_t *src, size_t count)
+{
+    ALOGD("MTK_downmix_to_mono_i16_from_stereo_i16");
+    while (count--) {
+        *dst++ = src[0];
+        src += 2;
+    }
+}
+#endif
+
 // ----------------------------------------------------------------------------
 
 #ifdef ADD_BATTERY_DATA
@@ -5938,8 +5953,13 @@ reacquire_wakelock:
                                 framesOut);
                         // the resampler always outputs stereo samples:
                         // do post stereo to mono conversion
+#ifdef MTK_HARDWARE                  
+                        MTK_downmix_to_mono_i16_from_stereo_i16(activeTrack->mSink.i16, (int16_t *)activeTrack->mRsmpOutBuffer,
+                                framesOut);
+#else     
                         downmix_to_mono_i16_from_stereo_i16(activeTrack->mSink.i16,
                                 (const int16_t *)activeTrack->mRsmpOutBuffer, framesOut);
+#endif
                     } else {
                         ditherAndClamp((int32_t *)activeTrack->mSink.raw,
                                 activeTrack->mRsmpOutBuffer, framesOut);
diff --git a/services/audiopolicy/AudioPolicyInterfaceImplLegacy.cpp b/services/audiopolicy/AudioPolicyInterfaceImplLegacy.cpp
index 146718817..e063a52fe 100644
--- a/services/audiopolicy/AudioPolicyInterfaceImplLegacy.cpp
+++ b/services/audiopolicy/AudioPolicyInterfaceImplLegacy.cpp
@@ -475,6 +475,7 @@ bool AudioPolicyService::isStreamActive(audio_stream_type_t stream, uint32_t inP
 
 bool AudioPolicyService::isStreamActiveRemotely(audio_stream_type_t stream, uint32_t inPastMs) const
 {
+#if !defined(ICS_AUDIO_BLOB) && !defined(MR1_AUDIO_BLOB)
     if (uint32_t(stream) >= AUDIO_STREAM_CNT) {
         return BAD_VALUE;
     }
@@ -483,6 +484,9 @@ bool AudioPolicyService::isStreamActiveRemotely(audio_stream_type_t stream, uint
     }
     Mutex::Autolock _l(mLock);
     return mpAudioPolicy->is_stream_active_remotely(mpAudioPolicy, stream, inPastMs);
+#else
+    return 0;
+#endif
 }
 
 bool AudioPolicyService::isSourceActive(audio_source_t source) const
@@ -494,6 +498,10 @@ bool AudioPolicyService::isSourceActive(audio_source_t source) const
         return false;
     }
     Mutex::Autolock _l(mLock);
+#ifdef HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+    if (source == AUDIO_SOURCE_HOTWORD)
+      source = AUDIO_SOURCE_VOICE_RECOGNITION;
+#endif
     return mpAudioPolicy->is_source_active(mpAudioPolicy, source);
 }
 
@@ -519,9 +527,9 @@ status_t AudioPolicyService::queryDefaultPreProcessing(int audioSession,
 
 bool AudioPolicyService::isOffloadSupported(const audio_offload_info_t& info)
 {
-#if HAVE_PRE_KITKAT_AUDIO_POLICY_BLOB
+#ifdef HAVE_PRE_KITKAT_AUDIO_BLOB
     return false;
-#endif
+#else
     if (mpAudioPolicy == NULL) {
         ALOGV("mpAudioPolicy == NULL");
         return false;
@@ -533,6 +541,7 @@ bool AudioPolicyService::isOffloadSupported(const audio_offload_info_t& info)
     }
 
     return mpAudioPolicy->is_offload_supported(mpAudioPolicy, &info);
+#endif
 }
 
 status_t AudioPolicyService::listAudioPorts(audio_port_role_t role __unused,
diff --git a/services/audiopolicy/AudioPolicyService.cpp b/services/audiopolicy/AudioPolicyService.cpp
index 30794541b..cd033c97f 100644
--- a/services/audiopolicy/AudioPolicyService.cpp
+++ b/services/audiopolicy/AudioPolicyService.cpp
@@ -276,6 +276,18 @@ void AudioPolicyService::setPowerHint(bool active) {
     }
 }
 
+#ifdef MTK_HARDWARE
+status_t AudioPolicyService::SetPolicyManagerParameters(int par1, int par2, int par3 , int par4)
+{
+    if (mpAudioPolicy == NULL) {
+        return 0;
+    }
+    //SetPolicyManagerParameters no need to hold mlock.
+    //Mutex::Autolock _l(mLock);
+    return mpAudioPolicy->set_policy_parameters(mpAudioPolicy, par1, par2,par3,par4);
+}
+#endif
+
 static bool tryLock(Mutex& mutex)
 {
     bool locked = false;
diff --git a/services/audiopolicy/AudioPolicyService.h b/services/audiopolicy/AudioPolicyService.h
index fe2a3f657..7dd3c1419 100644
--- a/services/audiopolicy/AudioPolicyService.h
+++ b/services/audiopolicy/AudioPolicyService.h
@@ -129,7 +129,9 @@ public:
     virtual bool isStreamActive(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isStreamActiveRemotely(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isSourceActive(audio_source_t source) const;
-
+#ifdef MTK_HARDWARE
+    virtual status_t SetPolicyManagerParameters(int par1, int par2, int par3 , int par4);
+#endif
     virtual status_t queryDefaultPreProcessing(int audioSession,
                                               effect_descriptor_t *descriptors,
                                               uint32_t *count);
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index b17be82be..7563b7142 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -83,6 +83,10 @@ ifneq ($(BOARD_NUMBER_OF_CAMERAS),)
     LOCAL_CFLAGS += -DMAX_CAMERAS=$(BOARD_NUMBER_OF_CAMERAS)
 endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_CFLAGS += -DMTK_MT6589
+endif
+
 LOCAL_MODULE:= libcameraservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 0d4fabff8..471ddfc7e 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -24,6 +24,9 @@
 #include "device1/CameraHardwareInterface.h"
 #include "CameraService.h"
 
+#ifdef MTK_MT6589
+#include <camera/MtkCamera.h>
+#endif
 namespace android {
 
 #define LOG1(...) ALOGD_IF(gLogLevel >= 1, __VA_ARGS__);
@@ -92,6 +95,9 @@ status_t CameraClient::initialize(camera_module_t *module) {
     enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
                   CAMERA_MSG_PREVIEW_METADATA | CAMERA_MSG_FOCUS_MOVE);
 
+#ifdef MTK_MT6589
+    enableMsgType(MTK_CAMERA_MSG_EXT_NOTIFY | MTK_CAMERA_MSG_EXT_DATA);
+#endif
     LOG1("CameraClient::initialize X (pid %d, id %d)", callingPid, mCameraId);
     return OK;
 }
@@ -713,7 +719,8 @@ void CameraClient::disableMsgType(int32_t msgType) {
 
 #define CHECK_MESSAGE_INTERVAL 10 // 10ms
 bool CameraClient::lockIfMessageWanted(int32_t msgType) {
-#ifdef MTK_HARDWARE
+#ifdef MTK_MT6589
+    // TODO check if this hack can't be avoided
     return true;
 #endif
     int sleepCount = 0;
@@ -767,6 +774,7 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
         int32_t ext2, void* user) {
     LOG2("notifyCallback(%d)", msgType);
 
+#if 0
 #ifdef MTK_HARDWARE
     if (msgType == 0x40000000) { //MTK_CAMERA_MSG_EXT_NOTIFY
         if (ext1 == 0x11) { //MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER
@@ -777,6 +785,7 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
         }
         LOG2("MtknotifyCallback(0x%x, 0x%x)", ext1, ext2);
     }
+#endif
 #endif
 
     Mutex* lock = getClientLockFromCookie(user);
@@ -790,6 +799,11 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
     if (!client->lockIfMessageWanted(msgType)) return;
 
     switch (msgType) {
+#ifdef MTK_MT6589
+    case MTK_CAMERA_MSG_EXT_NOTIFY:
+	    client->handleMtkExtNotify(ext1, ext2);
+	    break;
+#endif	
         case CAMERA_MSG_SHUTTER:
             // ext1 is the dimension of the yuv picture.
             client->handleShutter();
@@ -818,7 +832,7 @@ void CameraClient::dataCallback(int32_t msgType,
         client->handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
         return;
     }
-
+#if 0
 #ifdef MTK_HARDWARE
     if (msgType == 0x80000000) { //MTK_CAMERA_MSG_EXT_DATA
         struct DataHeader {
@@ -845,9 +859,15 @@ void CameraClient::dataCallback(int32_t msgType,
         }
         LOG2("MtkDataCallback(0x%x)", dataHeader.extMsgType);
     }
+#endif
 #endif
 
     switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
+#ifdef  MTK_MT6589
+        case MTK_CAMERA_MSG_EXT_DATA:
+            client->handleMtkExtData(dataPtr, metadata);
+            break;
+#endif
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
             break;
@@ -1097,4 +1117,292 @@ int CameraClient::getOrientation(int degrees, bool mirror) {
     return -1;
 }
 
+#ifdef MTK_MT6589
+/******************************************************************************
+*
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtNotify(int32_t ext1, int32_t ext2)
+{
+    ALOGE("CAMERA CLIENT GOT a mtk ext msg");
+    int32_t const extMsgType = ext1;
+    switch  (extMsgType)
+    {
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE:
+	    ALOGE("CAPTURE_DONE");
+	    disableMsgType(CAMERA_MSG_SHUTTER);
+	    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER:
+	    handleMtkExtShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER:
+        handleMtkExtBurstShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER:
+        handleMtkExtContinuousShutter(ext1, ext2);
+        break;
+    case MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END:
+        handleMtkExtContinuousEnd(ext1, ext2);
+        break;
+    default:
+        ALOGE("WTF is going on here?");
+        handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+        break;
+    }
+}
+
+
+/******************************************************************************
+*   Burst Shutter Callback Handler
+*       ext2: count-down shutter number; 0: the last one shutter.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtBurstShutter(int32_t, int32_t ext2)
+{
+    ALOGE("handleMtkExtBurstShutter");
+    handleShutter();
+    if  (0 < ext2) {
+        //  not the last one burst shutter.
+        enableMsgType(CAMERA_MSG_SHUTTER);
+        ALOGD("[handleMtkExtBurstShutter] count-down burst shutter number:%d - enableMsgType(CAMERA_MSG_SHUTTER) \r\n", ext2);
+    }
+    else {
+        ALOGD("[handleMtkExtBurstShutter] the last one burst shutter \r\n");
+    }
+}
+
+
+/******************************************************************************
+*   Burst Shot (EV Shot)
+*       int[0]: the total shut count.
+*       int[1]: count-down shut number; 0: the last one shut.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *)
+{
+    ALOGE("handleMtkExtDataBurstShot");
+
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uTotalShutCount = pExtParam[0];
+    uint_t const uCountdownIndex = pExtParam[1];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 2;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 2;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+    //
+    //
+    if  (0 < uCountdownIndex) {
+        //  not the last one burst shut.
+        ALOGD("[%s] count-down burst shut number:%d/%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uCountdownIndex, uTotalShutCount, imageSize, imageOffset);
+    }
+    else {
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+        ALOGD("[%s] the last one burst shut - (size, offset)=(%d, %d) \r\n", __FUNCTION__, imageSize, imageOffset);
+    }
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+    mLock.unlock();
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+
+/******************************************************************************
+*  Continuous Shutter Callback Handler
+*       ext2: current continuous shutter number.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousShutter(int32_t, int32_t ext2)
+{
+    ALOGE ("handleMtkExtContinuousShutter");
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+        mLock.unlock();
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+    mLock.unlock();
+    ALOGE("[handleMtkExtContinuousShutter] current continuous shutter number:%d \n", ext2);
+}
+
+/******************************************************************************
+*   Continuous EndCallback Handler
+* 
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2)
+{
+    ALOGE("handleMtkExtContinuousEnd");
+
+    disableMsgType(CAMERA_MSG_SHUTTER);
+    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    handleGenericNotify(MTK_CAMERA_MSG_EXT_NOTIFY, ext1, ext2);
+    ALOGE("[handleMtkExtContinuousEnd] total continuous shut number is %d \n", ext2);
+}
+
+
+/******************************************************************************
+*   Continuous Shot
+*       int[0]: current continuous shut number.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *)
+{
+    ALOGE("handleMtkExtDataContinuousShot");
+
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    //
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const uCurShutCount = pExtParam[0];
+    //
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    //
+    MtkExtDataHelper.uninit();
+
+    ALOGE("[%s] current continuous shut number:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__,  uCurShutCount, imageSize, imageOffset);
+
+    //
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+    mLock.unlock();
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+/******************************************************************************
+*
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata)
+{
+    ALOGE("handleMtkExtData");
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[handleMtkExtData] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p)", dataPtr.get(), this);
+        return;
+    }
+
+    MtkExtDataHelper.getExtParamBase();
+    MtkExtDataHelper.getExtParamSize();
+    switch  (MtkExtDataHelper.getExtMsgType())
+    {
+    case MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE:
+        handleMtkExtDataCompressedImage(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT:
+        handleMtkExtDataBurstShot(dataPtr, metadata);
+        break;
+    //
+    case MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT:
+        handleMtkExtDataContinuousShot(dataPtr, metadata);
+        break;
+    //
+    default:
+	    ALOGE("WTF is going on in handleMtkExtData...");
+        handleGenericData(MTK_CAMERA_MSG_EXT_DATA, dataPtr, metadata);
+        break;
+    }
+    MtkExtDataHelper.uninit();
+}
+
+
+/******************************************************************************
+*   Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+*       ext2: 1: CameraService will play shutter sound.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtShutter(int32_t, int32_t ext2)
+{ 
+    ALOGD("[%s] (ext2, mPlayShutterSound)=(%d, %d) \r\n", __FUNCTION__, ext2, mPlayShutterSound);
+
+    if  ( 1 == ext2 ) {
+        if (mPlayShutterSound) {
+            mCameraService->playSound(CameraService::SOUND_SHUTTER);
+        }
+    }
+ 
+    sp<ICameraClient> c = mRemoteCallback;
+    if (c != 0) {
+        mLock.unlock();
+        c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
+        if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
+    }
+    
+//    disableMsgType(CAMERA_MSG_SHUTTER);
+
+    mLock.unlock();
+}
+
+
+/******************************************************************************
+*   Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+*       int[0]: current shut index; 0: the first one shut.
+*******************************************************************************/
+void
+CameraClient::
+handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t *)
+{
+    ALOGE("handleMtkExtDataCompressedImage");
+
+    MtkCamMsgExtDataHelper MtkExtDataHelper;
+    if  ( ! MtkExtDataHelper.init(dataPtr) ) {
+        ALOGE("[%s] MtkCamMsgExtDataHelper::init fail - dataPtr(%p), this(%p) \r\n", __FUNCTION__, dataPtr.get(), this);
+        return;
+    }
+    uint_t const*const pExtParam = (uint_t const*)MtkExtDataHelper.getExtParamBase();
+    uint_t const      uShutIndex = pExtParam[0];
+    size_t const    imageSize   = MtkExtDataHelper.getExtParamSize()    - sizeof(uint_t) * 1;
+    ssize_t const   imageOffset = MtkExtDataHelper.getExtParamOffset()  + sizeof(uint_t) * 1;
+    sp<MemoryBase> image = new MemoryBase(MtkExtDataHelper.getHeap(), imageOffset, imageSize);
+    MtkExtDataHelper.uninit();
+
+    ALOGE("[%s] current shut index:%d - (size, offset)=(%d, %d) \r\n", __FUNCTION__, uShutIndex, imageSize, imageOffset);
+    if (image == 0) {
+        ALOGE("[%s] fail to new MemoryBase \r\n", __FUNCTION__);
+        return;
+    }
+
+    //
+    sp<ICameraClient> c = mRemoteCallback;
+    mLock.unlock();
+
+    if (c != 0) {
+        c->dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, image, NULL);
+    }
+}
+#endif
 }; // namespace android
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index eda1a9f83..946487997 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -164,6 +164,18 @@ private:
     // This function keeps trying to grab mLock, or give up if the message
     // is found to be disabled. It returns true if mLock is grabbed.
     bool                    lockIfMessageWanted(int32_t msgType);
+#ifdef  MTK_MT6589
+    void                    handleMtkExtNotify(int32_t ext1, int32_t ext2);
+    void                    handleMtkExtData(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    void                    handleMtkExtBurstShutter(int32_t ext1, int32_t ext2);
+    void                    handleMtkExtDataBurstShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    void                    handleMtkExtContinuousShutter(int32_t ext1, int32_t ext2);
+    void                    handleMtkExtDataContinuousShot(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    void                    handleMtkExtContinuousEnd(int32_t ext1, int32_t ext2);
+    void                    handleMtkExtShutter(int32_t ext1, int32_t ext2);
+    void                    handleMtkExtDataCompressedImage(const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata);
+    void                    playRecordingSound();
+#endif 
 };
 
 }
